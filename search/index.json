[{"content":"大模型应用开发(或搭建)有效实践 \u0026ndash;智能体开发(或搭建)有效实践 ​ 执行者-评判者模式\n​ 协调者-工作者模式\n​ 郑州数能软件科技有限公司 张子彪\n背景： Uncertainty\n一、案例 审计监督案例文章：穿透迷雾的智慧交通项目资金追踪\n↓\n二、常规oneshot模式 一次性将提示词提交LLM， 提示词如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 ### 角色 你是一位经验丰富、专业精湛的资深审计专家，凭借深厚的专业知识和敏锐的洞察力，从给定文本中精准且全面地抽取出各类审计相关的具体问题案例。按以下工作步骤执行 ### 工作流程： #### 第一阶段：抽取问题类型和案例概述 ##### 第一步: 抽取问题类型 1. 深入细致地研读给定文本，以这19个问题类型作为参考方向：：内控体系建设与监督、研发投入、采购管理（供应商、招标采购）、虚假贸易、信托业务、私募基金、财务公司、融资租赁、工程建设(违规转分包)、股权投资(无关多元、违规挂靠)、控股不控权、虚假控股、产权管理(多层架构)、薪酬分配(薪酬乱象)、债务风险(过度负债)、资金风险(违规出借资金、违规拖欠)、财务风险、境外业务风险、靠企吃企。以问题方向为出发点，多维度的尽量找出全部审计相关问题。至少从不同方向提炼出5个问题，尽可能深入挖掘更多相关的问题。 ##### 第二步：总结案例概述 1. 根据上一步确定的问题类型和对应的问题，准确抽取总结与之相关联的案例概述。案例概述要简洁明了，涵盖关键信息。 #### 第二阶段：根据上一阶段抽取的N组问题类型和案例概述，针对每一组问题逐个抽取总结问题的详细信息：问题情形、线索发现、审计方法、证据链 ##### 第一步: 抽取问题情形 1. 从文章中抽取问题相关的问题情形 ##### 第二步：抽取线索发现 1. 从文章中抽取问题相关的线索 ##### 第三步：抽取审计方法 1. 从文章中抽取问题相关的审计方法 ##### 第四步: 梳理证据链 1. 以清晰的序号形式回答证据链，序号和证据之间使用点分隔，证据和概述之间用冒号分隔。 2. 仅从文中抽取真实、准确的相关证据链信息，坚决不编造任何证据内容。 ##### 第五步: 整理政策依据 按照 \u0026#34;发文部门、法规名称、法规文号、条款、对应的内容\u0026#34; 的格式，用精准、详细的一句话准确回答政策依据。法条内容需完整、细致地写出。 例如：\u0026#34;财政部《关于进一步加强地方财政预算执行管理的通知》（财预〔2018〕65 号）第三条：严禁无具体项目或超项目进度安排预算资金\u0026#34;； ##### 第六步: 细化线索发现等内容 1. 线索发现、审计方法、证据链里的细分条目都要从文章中抽取详尽的描述，不虚构、不编造信息。 2. 线索发现可根据文本实际情况回答多条，问题情形至少抽取四条，尽可能充分地列举相关信息。 ##### 第七步: 自我审查 1. 抽取完成后，仔细检查每条抽取内容是否有明确的原文依据，若没有则重新进行抽取。 2. 着重严格核查所有栏目里涉及的数值与名词的正确性与完整性，如文件中标明数值 664.23，抽取结果必须精确呈现，不可简化为 664。对于数值和名词，要确保在每一处细节上都准确无误。 3. 对证据链里的逻辑性进行严谨审查，特别是时间方面，杜绝出现任何不合理、胡编乱造的情况。 4. 名词部分严格以案件信息中的信息为基准，不进行无端推测。例如文件中没有明确提及现场照片，不可以自行推断照片的存在。 ##### 第八步: 规范输出格式 按照以下格式进行回答： \\[{\\\u0026#34;问题类型\\\u0026#34;：\\\u0026#34;\\\u0026#34;, \\\u0026#34;案例概述\\\u0026#34;：\\\u0026#34;\\\u0026#34;, \\\u0026#34;问题情形\\\u0026#34;：[], \\\u0026#34;线索发现\\\u0026#34;:[{\\\u0026#34;线索\\\u0026#34;：\\\u0026#34;\\\u0026#34;,\\\u0026#34;概述\\\u0026#34;：\\\u0026#34;\\\u0026#34;}], \\\u0026#34;审计方法\\\u0026#34;:[{\\\u0026#34;方法\\\u0026#34;：\\\u0026#34;\\\u0026#34;,\\\u0026#34;概述\\\u0026#34;：\\\u0026#34;\\\u0026#34;}], \\\u0026#34;证据链\\\u0026#34;:[], \\\u0026#34;政策依据\\\u0026#34;:[], }\\] ### 限制: - 只依据给定文本进行信息抽取和分析，绝不虚构、不添加任何额外信息。 - 所输出的内容必须严格按照给定格式进行组织，不得有任何偏离框架要求的情况。 - 抽取的每条内容都需要有具体、明确的来源依据 。 ###################### 给定文本:{input_text} 三、执行者-评判者模式 \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n四、协调者-工作者模式 五、实现 该模式可以在dify或其他智能体平台上搭建\n[Dify 是低代码平台, 可视化界面，少量代码或配置，适合非技术团队]\n自主编码开发， 最好借助langgraph\n[面向开发者的Agent编程框架]\n","date":"2025-08-01T17:13:06+08:00","permalink":"https://zhangzib123.github.io/p/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%88%96%E6%90%AD%E5%BB%BA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/","title":"大模型应用开发(或搭建)有效实践"},{"content":"AICoreHub 两级用户体系设计 📋 概述 基于AICoreHub作为\u0026quot;企业AI能力的总线与中枢\u0026quot;的定位，采用两级用户体系，既满足小型企业的管理需求，又保持系统的简洁性和易用性。\n🎯 用户分级 1. 管理员 (Admin) 权限范围：系统级完全管理 典型用户：IT负责人、系统管理员、技术主管 主要职责： 用户账户管理 LLM模型配置管理 系统监控和维护 全局数据查看 2. 普通用户 (User) 权限范围：个人使用权限 典型用户：开发工程师、业务人员、客服、市场人员 主要职责： 个人Prompt模板管理 服务调用和测试 个人数据查看 📊 权限矩阵 功能模块 Admin User 说明 用户管理 ✅ 增删改查 ❌ 管理员可创建、删除、修改用户账户 LLM配置 ✅ 增删改查 ✅ 查看 管理员可配置、管理所有LLM模型 服务发现 ✅ 全部 ✅ 查看 所有用户可查看服务列表 调用历史 ✅ 全部 ✅ 个人 管理员看全部，用户只看自己的 成本监控 ✅ 全部 ✅ 个人 管理员看全局成本，用户看个人成本 Prompt管理 ✅ 增删改查所有 ✅ 增删改自己的，查看所有 用户可创建个人模板，查看所有模板 系统监控 ✅ 全部 ❌ 管理员可查看系统健康状态、QPS等 🏗️ 技术实现 后端权限控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 from enum import Enum from functools import wraps from fastapi import HTTPException, Depends from fastapi.security import HTTPBearer class UserRole(Enum): ADMIN = \u0026#34;admin\u0026#34; USER = \u0026#34;user\u0026#34; class UserManager: def __init__(self): self.storage = FileStorage() def get_user(self, user_id: str) -\u0026gt; Optional[dict]: data = self.storage.read_json(\u0026#34;users.json\u0026#34;) return data.get(\u0026#34;users\u0026#34;, {}).get(user_id) def is_admin(self, user_id: str) -\u0026gt; bool: user = self.get_user(user_id) return user and user.get(\u0026#34;role\u0026#34;) == \u0026#34;admin\u0026#34; # 权限装饰器 def require_admin(func): @wraps(func) async def wrapper(request: Request, *args, **kwargs): user_id = get_current_user_id(request) if not user_manager.is_admin(user_id): raise HTTPException(403, \u0026#34;需要管理员权限\u0026#34;) return await func(request, *args, **kwargs) return wrapper def require_auth(func): @wraps(func) async def wrapper(request: Request, *args, **kwargs): user_id = get_current_user_id(request) if not user_id: raise HTTPException(401, \u0026#34;需要登录\u0026#34;) return await func(request, *args, **kwargs) return wrapper # API接口权限控制 @app.post(\u0026#34;/api/llm/add\u0026#34;) @require_admin async def add_llm(model: dict = Body(...)): \u0026#34;\u0026#34;\u0026#34;添加LLM模型 - 仅管理员\u0026#34;\u0026#34;\u0026#34; pass @app.post(\u0026#34;/api/llm/delete\u0026#34;) @require_admin async def delete_llm(model: dict = Body(...)): \u0026#34;\u0026#34;\u0026#34;删除LLM模型 - 仅管理员\u0026#34;\u0026#34;\u0026#34; pass @app.get(\u0026#34;/api/prompt/list\u0026#34;) @require_auth async def list_prompts(current_user: dict = Depends(get_current_user)): \u0026#34;\u0026#34;\u0026#34;获取Prompt列表 - 管理员看全部，用户看全部（只读）\u0026#34;\u0026#34;\u0026#34; if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): prompts = prompt_manager.get_all_prompts() else: prompts = prompt_manager.get_all_prompts_readonly() return {\u0026#34;prompts\u0026#34;: prompts} @app.post(\u0026#34;/api/prompt/add\u0026#34;) @require_auth async def add_prompt( name: str, content: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;添加Prompt - 管理员可添加任何，用户只能添加自己的\u0026#34;\u0026#34;\u0026#34; if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): prompt_id = prompt_manager.create_prompt(name, content, None) # 管理员可创建公共模板 else: prompt_id = prompt_manager.create_prompt(name, content, current_user[\u0026#34;id\u0026#34;]) return {\u0026#34;id\u0026#34;: prompt_id, \u0026#34;message\u0026#34;: \u0026#34;创建成功\u0026#34;} @app.delete(\u0026#34;/api/prompt/{prompt_id}\u0026#34;) @require_auth async def delete_prompt( prompt_id: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;删除Prompt - 管理员可删除任何，用户只能删除自己的\u0026#34;\u0026#34;\u0026#34; prompt = prompt_manager.get_prompt(prompt_id) if not prompt: raise HTTPException(404, \u0026#34;Prompt不存在\u0026#34;) if not user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]) and prompt[\u0026#34;user_id\u0026#34;] != current_user[\u0026#34;id\u0026#34;]: raise HTTPException(403, \u0026#34;只能删除自己的Prompt\u0026#34;) prompt_manager.delete_prompt(prompt_id) return {\u0026#34;message\u0026#34;: \u0026#34;删除成功\u0026#34;} 前端权限控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // 权限配置 const PERMISSIONS = { ADMIN: [\u0026#39;*\u0026#39;], // 管理员拥有所有权限 USER: [\u0026#39;history\u0026#39;, \u0026#39;prompt_manage\u0026#39;, \u0026#39;service_call\u0026#39;, \u0026#39;cost_view\u0026#39;] } // 权限检查函数 function hasPermission(permission) { const userRole = userStore.role return PERMISSIONS[userRole].includes(\u0026#39;*\u0026#39;) || PERMISSIONS[userRole].includes(permission) } // 用户状态管理 const userStore = reactive({ id: null, username: \u0026#39;\u0026#39;, role: \u0026#39;user\u0026#39;, isAuthenticated: false }) // 菜单权限控制 const menuItems = computed(() =\u0026gt; { const items = [ { name: \u0026#39;LLM监控\u0026#39;, key: \u0026#39;dashboard\u0026#39;, permission: \u0026#39;cost_view\u0026#39; }, { name: \u0026#39;服务发现\u0026#39;, key: \u0026#39;discovery\u0026#39;, permission: \u0026#39;service_discovery\u0026#39; }, { name: \u0026#39;调用历史\u0026#39;, key: \u0026#39;history\u0026#39;, permission: \u0026#39;history\u0026#39; }, { name: \u0026#39;LLM配置\u0026#39;, key: \u0026#39;llmconfig\u0026#39;, permission: \u0026#39;llm_config\u0026#39; }, { name: \u0026#39;Prompt管理\u0026#39;, key: \u0026#39;prompt\u0026#39;, permission: \u0026#39;prompt_manage\u0026#39; }, { name: \u0026#39;帮助\u0026#39;, key: \u0026#39;help\u0026#39;, permission: \u0026#39;*\u0026#39; } ] return items.filter(item =\u0026gt; hasPermission(item.permission)) }) // Prompt管理组件权限控制 const PromptManager = { setup() { const userRole = userStore.role const isAdmin = userRole === \u0026#39;ADMIN\u0026#39; // 检查是否可以编辑Prompt const canEdit = (prompt) =\u0026gt; { return isAdmin || prompt.user_id === userStore.id } // 检查是否可以删除Prompt const canDelete = (prompt) =\u0026gt; { return isAdmin || prompt.user_id === userStore.id } // 检查是否可以创建Prompt const canCreate = () =\u0026gt; { return true // 所有用户都可以创建 } return { canEdit, canDelete, canCreate } } } 💾 数据存储方案 轻量级JSON文件存储 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 import json import os from typing import Dict, List, Optional from datetime import datetime import threading class FileStorage: def __init__(self, data_dir: str = \u0026#34;data\u0026#34;): self.data_dir = data_dir self.lock = threading.Lock() os.makedirs(data_dir, exist_ok=True) def _get_file_path(self, filename: str) -\u0026gt; str: return os.path.join(self.data_dir, filename) def read_json(self, filename: str) -\u0026gt; dict: file_path = self._get_file_path(filename) if not os.path.exists(file_path): return {} with self.lock: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: return json.load(f) def write_json(self, filename: str, data: dict): file_path = self._get_file_path(filename) with self.lock: with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: json.dump(data, f, ensure_ascii=False, indent=2) class UserManager: def __init__(self): self.storage = FileStorage() def get_user(self, user_id: str) -\u0026gt; Optional[dict]: data = self.storage.read_json(\u0026#34;users.json\u0026#34;) return data.get(\u0026#34;users\u0026#34;, {}).get(user_id) def create_user(self, user_id: str, username: str, role: str = \u0026#34;user\u0026#34;): data = self.storage.read_json(\u0026#34;users.json\u0026#34;) if \u0026#34;users\u0026#34; not in data: data[\u0026#34;users\u0026#34;] = {} data[\u0026#34;users\u0026#34;][user_id] = { \u0026#34;id\u0026#34;: user_id, \u0026#34;username\u0026#34;: username, \u0026#34;role\u0026#34;: role, \u0026#34;created_at\u0026#34;: datetime.now().isoformat() } self.storage.write_json(\u0026#34;users.json\u0026#34;, data) def is_admin(self, user_id: str) -\u0026gt; bool: user = self.get_user(user_id) return user and user.get(\u0026#34;role\u0026#34;) == \u0026#34;admin\u0026#34; class UserPromptManager: def __init__(self): self.storage = FileStorage() self.prompt_dir = \u0026#34;config_prompts\u0026#34; # 使用现有Prompt目录 def get_user_prompts(self, user_id: str) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;获取用户的Prompt关联信息\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) return data.get(\u0026#34;user_prompts\u0026#34;, {}).get(user_id, { \u0026#34;owned_prompts\u0026#34;: [], \u0026#34;favorite_prompts\u0026#34;: [], \u0026#34;created_at\u0026#34;: datetime.now().isoformat() }) def get_user_accessible_prompts(self, user_id: str) -\u0026gt; List[str]: \u0026#34;\u0026#34;\u0026#34;获取用户可访问的Prompt文件名列表\u0026#34;\u0026#34;\u0026#34; user_prompts = self.get_user_prompts(user_id) # 获取所有Prompt文件 all_prompts = [] for fname in os.listdir(self.prompt_dir): if os.path.isfile(os.path.join(self.prompt_dir, fname)): all_prompts.append(fname) # 用户可以看到所有Prompt文件（只读） return all_prompts def can_user_edit_prompt(self, user_id: str, prompt_filename: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;检查用户是否可以编辑指定Prompt文件\u0026#34;\u0026#34;\u0026#34; user_prompts = self.get_user_prompts(user_id) return prompt_filename in user_prompts[\u0026#34;owned_prompts\u0026#34;] def add_user_prompt(self, user_id: str, prompt_filename: str, prompt_type: str = \u0026#34;owned\u0026#34;): \u0026#34;\u0026#34;\u0026#34;为用户添加Prompt关联\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) if \u0026#34;user_prompts\u0026#34; not in data: data[\u0026#34;user_prompts\u0026#34;] = {} if user_id not in data[\u0026#34;user_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id] = { \u0026#34;owned_prompts\u0026#34;: [], \u0026#34;favorite_prompts\u0026#34;: [], \u0026#34;created_at\u0026#34;: datetime.now().isoformat() } if prompt_type == \u0026#34;owned\u0026#34;: if prompt_filename not in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;].append(prompt_filename) elif prompt_type == \u0026#34;favorite\u0026#34;: if prompt_filename not in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;].append(prompt_filename) self.storage.write_json(\u0026#34;user_prompts.json\u0026#34;, data) def remove_user_prompt(self, user_id: str, prompt_filename: str, prompt_type: str = \u0026#34;owned\u0026#34;): \u0026#34;\u0026#34;\u0026#34;移除用户的Prompt关联\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) if user_id in data.get(\u0026#34;user_prompts\u0026#34;, {}): if prompt_type == \u0026#34;owned\u0026#34;: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;] = [ p for p in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;] if p != prompt_filename ] elif prompt_type == \u0026#34;favorite\u0026#34;: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;] = [ p for p in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;] if p != prompt_filename ] self.storage.write_json(\u0026#34;user_prompts.json\u0026#34;, data) # 保持现有PromptManager不变，用于兼容现有系统 class PromptManager: def __init__(self, prompt_dir=\u0026#34;config_prompts\u0026#34;): self.prompts = {} if not os.path.exists(prompt_dir): return for fname in os.listdir(prompt_dir): fpath = os.path.join(prompt_dir, fname) if fname.endswith(\u0026#34;.yaml\u0026#34;) or fname.endswith(\u0026#34;.yml\u0026#34;): with open(fpath, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: self.prompts[fname[:-5]] = yaml.safe_load(f) elif fname.endswith(\u0026#34;.json\u0026#34;): with open(fpath, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: self.prompts[fname[:-5]] = json.load(f) elif fname.endswith(\u0026#34;.ini\u0026#34;): cp = configparser.ConfigParser() cp.read(fpath, encoding=\u0026#34;utf-8\u0026#34;) self.prompts[fname[:-4]] = {s: dict(cp.items(s)) for s in cp.sections()} def get_prompt(self, plugin, template=\u0026#34;default\u0026#34;): # plugin: 文件名（不含扩展名），template: section/key p = self.prompts.get(plugin, {}) if isinstance(p, dict): return p.get(template, \u0026#34;\u0026#34;) return p 数据文件结构 1 2 3 4 5 6 7 8 9 10 11 data/ ├── users.json # 用户数据 ├── user_prompts.json # 用户与Prompt的关联关系 ├── history.json # 调用历史 └── llm_config.json # LLM配置 config_prompts/ # 现有Prompt模板存储目录（保持不变） ├── prompt.ini # 现有Prompt文件 ├── prom # 现有Prompt文件 ├── prompt_x.ini # 现有Prompt文件 └── ... # 其他现有Prompt文件 users.json 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;users\u0026#34;: { \u0026#34;admin1\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;admin1\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;系统管理员\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T10:00:00Z\u0026#34; }, \u0026#34;user1\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;user1\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T11:00:00Z\u0026#34; } } } user_prompts.json 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;user_prompts\u0026#34;: { \u0026#34;user1\u0026#34;: { \u0026#34;owned_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;, \u0026#34;custom_prompt.yaml\u0026#34;], \u0026#34;favorite_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;], \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T10:00:00Z\u0026#34; }, \u0026#34;user2\u0026#34;: { \u0026#34;owned_prompts\u0026#34;: [\u0026#34;my_prompt.json\u0026#34;], \u0026#34;favorite_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;, \u0026#34;prompt_x.ini\u0026#34;], \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T11:00:00Z\u0026#34; } } } 🔐 认证机制 简化认证方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 from fastapi import HTTPException, Depends from fastapi.security import HTTPBearer security = HTTPBearer() def get_current_user(token: str = Depends(security)): # 简化处理：token直接作为user_id # 实际项目中应使用JWT或其他认证方式 user_id = token.credentials user = user_manager.get_user(user_id) if not user: raise HTTPException(401, \u0026#34;用户不存在\u0026#34;) return user # 登录接口 @app.post(\u0026#34;/api/login\u0026#34;) async def login(username: str, password: str): # 简化处理：直接返回用户信息 # 实际项目中需要验证密码 user = user_manager.get_user_by_username(username) if not user: raise HTTPException(401, \u0026#34;用户名或密码错误\u0026#34;) return { \u0026#34;user_id\u0026#34;: user[\u0026#34;id\u0026#34;], \u0026#34;username\u0026#34;: user[\u0026#34;username\u0026#34;], \u0026#34;role\u0026#34;: user[\u0026#34;role\u0026#34;], \u0026#34;token\u0026#34;: user[\u0026#34;id\u0026#34;] # 简化处理 } # Prompt管理API接口 @app.get(\u0026#34;/api/prompt/list\u0026#34;) @require_auth async def list_prompts(current_user: dict = Depends(get_current_user)): \u0026#34;\u0026#34;\u0026#34;获取Prompt列表 - 兼容现有系统\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): # 管理员看到所有Prompt文件 prompt_files = user_prompt_manager.get_user_accessible_prompts(current_user[\u0026#34;id\u0026#34;]) else: # 普通用户看到所有Prompt文件（只读） prompt_files = user_prompt_manager.get_user_accessible_prompts(current_user[\u0026#34;id\u0026#34;]) # 返回文件名列表，兼容现有API return {\u0026#34;files\u0026#34;: prompt_files} @app.post(\u0026#34;/api/prompt/new\u0026#34;) @require_auth async def new_prompt_file( name: str = Body(...), content: str = Body(...), current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;创建新Prompt文件\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() # 检查文件是否已存在 file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, name) if os.path.exists(file_path): raise HTTPException(409, \u0026#34;文件已存在\u0026#34;) # 创建文件 with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(content) # 将文件关联到用户 user_prompt_manager.add_user_prompt(current_user[\u0026#34;id\u0026#34;], name, \u0026#34;owned\u0026#34;) return {\u0026#34;status\u0026#34;: \u0026#34;created\u0026#34;, \u0026#34;name\u0026#34;: name} @app.post(\u0026#34;/api/prompt/file\u0026#34;) @require_auth async def save_prompt_file( name: str = Body(...), content: str = Body(...), current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;保存Prompt文件 - 只能编辑自己的文件\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() if not user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): if not user_prompt_manager.can_user_edit_prompt(current_user[\u0026#34;id\u0026#34;], name): raise HTTPException(403, \u0026#34;只能编辑自己的Prompt文件\u0026#34;) # 保存文件 file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, name) with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(content) return {\u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;name\u0026#34;: name} @app.post(\u0026#34;/api/prompt/favorite/{prompt_filename}\u0026#34;) @require_auth async def favorite_prompt( prompt_filename: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;收藏Prompt文件\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() user_prompt_manager.add_user_prompt(current_user[\u0026#34;id\u0026#34;], prompt_filename, \u0026#34;favorite\u0026#34;) return {\u0026#34;message\u0026#34;: \u0026#34;收藏成功\u0026#34;} @app.delete(\u0026#34;/api/prompt/{prompt_filename}\u0026#34;) @require_auth async def delete_prompt( prompt_filename: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;删除Prompt文件 - 只能删除自己拥有的\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() user_prompts = user_prompt_manager.get_user_prompts(current_user[\u0026#34;id\u0026#34;]) if prompt_filename not in user_prompts[\u0026#34;owned_prompts\u0026#34;]: raise HTTPException(403, \u0026#34;只能删除自己的Prompt文件\u0026#34;) # 删除文件 file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, prompt_filename) if os.path.exists(file_path): os.remove(file_path) # 移除用户关联 user_prompt_manager.remove_user_prompt(current_user[\u0026#34;id\u0026#34;], prompt_filename, \u0026#34;owned\u0026#34;) return {\u0026#34;message\u0026#34;: \u0026#34;删除成功\u0026#34;} 📱 前端界面适配 用户角色显示 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;user-info\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ userStore.username }}\u0026lt;/span\u0026gt; \u0026lt;el-tag :type=\u0026#34;userStore.role === \u0026#39;admin\u0026#39; ? \u0026#39;danger\u0026#39; : \u0026#39;primary\u0026#39;\u0026#34;\u0026gt; {{ userStore.role === \u0026#39;admin\u0026#39; ? \u0026#39;管理员\u0026#39; : \u0026#39;用户\u0026#39; }} \u0026lt;/el-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 权限控制组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 只有管理员可见 --\u0026gt; \u0026lt;div v-if=\u0026#34;hasPermission(\u0026#39;user_manage\u0026#39;)\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;manageUsers\u0026#34;\u0026gt;用户管理\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 所有用户可见 --\u0026gt; \u0026lt;div v-if=\u0026#34;hasPermission(\u0026#39;prompt_manage\u0026#39;)\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;createPrompt\u0026#34;\u0026gt;创建Prompt\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { computed } from \u0026#39;vue\u0026#39; import { useUserStore } from \u0026#39;@/stores/user\u0026#39; const userStore = useUserStore() const hasPermission = (permission) =\u0026gt; { return userStore.hasPermission(permission) } \u0026lt;/script\u0026gt; 🚀 部署和配置 初始化脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # init_users.py from user_manager import UserManager def init_default_users(): user_manager = UserManager() # 创建默认管理员 user_manager.create_user( user_id=\u0026#34;admin\u0026#34;, username=\u0026#34;系统管理员\u0026#34;, role=\u0026#34;admin\u0026#34; ) # 创建默认用户 user_manager.create_user( user_id=\u0026#34;user1\u0026#34;, username=\u0026#34;测试用户\u0026#34;, role=\u0026#34;user\u0026#34; ) print(\u0026#34;默认用户创建完成\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: init_default_users() 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 # config.py class Config: # 数据存储路径 DATA_DIR = \u0026#34;data\u0026#34; # 默认用户角色 DEFAULT_USER_ROLE = \u0026#34;user\u0026#34; # 权限配置 PERMISSIONS = { \u0026#34;admin\u0026#34;: [\u0026#34;*\u0026#34;], \u0026#34;user\u0026#34;: [\u0026#34;history\u0026#34;, \u0026#34;prompt_manage\u0026#34;, \u0026#34;service_call\u0026#34;, \u0026#34;cost_view\u0026#34;] } 📈 升级路径 当前方案优势 简单易用：两级权限，逻辑清晰 快速部署：JSON文件存储，零依赖 成本低廉：无需数据库，维护简单 易于扩展：为后续升级预留空间 完全兼容：保持现有Prompt存储方式不变 未来升级方向 1 2 3 4 5 当前：JSON文件 + 两级权限 + 现有Prompt存储 ↓ 中期：SQLite + 三级权限（增加开发者角色） ↓ 长期：MySQL + 四级权限（完整企业级权限体系） 兼容性说明 现有Prompt系统：完全保持不变，继续使用 config_prompts/ 目录 用户权限管理：通过 user_prompts.json 管理用户与Prompt的关联关系 API接口：兼容现有的Prompt API，同时增加权限控制 业务逻辑：现有业务代码无需修改，权限控制在API层实现 ✅ 实施检查清单 后端开发 实现FileStorage类 实现UserManager类 实现UserPromptManager类（新增） 保持现有PromptManager类不变 添加权限装饰器 修改API接口支持权限控制 实现认证机制 确保与现有Prompt API兼容 前端开发 实现用户状态管理 添加权限检查函数 修改菜单显示逻辑 适配Prompt管理界面 添加用户角色显示 测试验证 管理员权限测试 普通用户权限测试 Prompt管理功能测试 数据隔离测试 权限升级测试 现有Prompt系统兼容性测试 用户Prompt关联关系测试 文档版本：v1.0\n创建时间：2025年7月\n适用场景：小型企业（\u0026lt; 50人）\n技术栈：FastAPI + Vue.js + JSON文件存储\n","date":"2025-07-31T18:22:48+08:00","permalink":"https://zhangzib123.github.io/p/aicorehub-%E4%B8%A4%E7%BA%A7%E7%94%A8%E6%88%B7%E4%BD%93%E7%B3%BB%E8%AE%BE%E8%AE%A1/","title":"AICoreHub 两级用户体系设计"},{"content":"文章标题 文章内容111 ","date":"2025-07-31T15:22:48+08:00","permalink":"https://zhangzib123.github.io/p/abc/","title":"Abc"}]