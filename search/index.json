[{"content":"AICoreHub ä¸¤çº§ç”¨æˆ·ä½“ç³»è®¾è®¡ ğŸ“‹ æ¦‚è¿° åŸºäºAICoreHubä½œä¸º\u0026quot;ä¼ä¸šAIèƒ½åŠ›çš„æ€»çº¿ä¸ä¸­æ¢\u0026quot;çš„å®šä½ï¼Œé‡‡ç”¨ä¸¤çº§ç”¨æˆ·ä½“ç³»ï¼Œæ—¢æ»¡è¶³å°å‹ä¼ä¸šçš„ç®¡ç†éœ€æ±‚ï¼Œåˆä¿æŒç³»ç»Ÿçš„ç®€æ´æ€§å’Œæ˜“ç”¨æ€§ã€‚\nğŸ¯ ç”¨æˆ·åˆ†çº§ 1. ç®¡ç†å‘˜ (Admin) æƒé™èŒƒå›´ï¼šç³»ç»Ÿçº§å®Œå…¨ç®¡ç† å…¸å‹ç”¨æˆ·ï¼šITè´Ÿè´£äººã€ç³»ç»Ÿç®¡ç†å‘˜ã€æŠ€æœ¯ä¸»ç®¡ ä¸»è¦èŒè´£ï¼š ç”¨æˆ·è´¦æˆ·ç®¡ç† LLMæ¨¡å‹é…ç½®ç®¡ç† ç³»ç»Ÿç›‘æ§å’Œç»´æŠ¤ å…¨å±€æ•°æ®æŸ¥çœ‹ 2. æ™®é€šç”¨æˆ· (User) æƒé™èŒƒå›´ï¼šä¸ªäººä½¿ç”¨æƒé™ å…¸å‹ç”¨æˆ·ï¼šå¼€å‘å·¥ç¨‹å¸ˆã€ä¸šåŠ¡äººå‘˜ã€å®¢æœã€å¸‚åœºäººå‘˜ ä¸»è¦èŒè´£ï¼š ä¸ªäººPromptæ¨¡æ¿ç®¡ç† æœåŠ¡è°ƒç”¨å’Œæµ‹è¯• ä¸ªäººæ•°æ®æŸ¥çœ‹ ğŸ“Š æƒé™çŸ©é˜µ åŠŸèƒ½æ¨¡å— Admin User è¯´æ˜ ç”¨æˆ·ç®¡ç† âœ… å¢åˆ æ”¹æŸ¥ âŒ ç®¡ç†å‘˜å¯åˆ›å»ºã€åˆ é™¤ã€ä¿®æ”¹ç”¨æˆ·è´¦æˆ· LLMé…ç½® âœ… å¢åˆ æ”¹æŸ¥ âœ… æŸ¥çœ‹ ç®¡ç†å‘˜å¯é…ç½®ã€ç®¡ç†æ‰€æœ‰LLMæ¨¡å‹ æœåŠ¡å‘ç° âœ… å…¨éƒ¨ âœ… æŸ¥çœ‹ æ‰€æœ‰ç”¨æˆ·å¯æŸ¥çœ‹æœåŠ¡åˆ—è¡¨ è°ƒç”¨å†å² âœ… å…¨éƒ¨ âœ… ä¸ªäºº ç®¡ç†å‘˜çœ‹å…¨éƒ¨ï¼Œç”¨æˆ·åªçœ‹è‡ªå·±çš„ æˆæœ¬ç›‘æ§ âœ… å…¨éƒ¨ âœ… ä¸ªäºº ç®¡ç†å‘˜çœ‹å…¨å±€æˆæœ¬ï¼Œç”¨æˆ·çœ‹ä¸ªäººæˆæœ¬ Promptç®¡ç† âœ… å¢åˆ æ”¹æŸ¥æ‰€æœ‰ âœ… å¢åˆ æ”¹è‡ªå·±çš„ï¼ŒæŸ¥çœ‹æ‰€æœ‰ ç”¨æˆ·å¯åˆ›å»ºä¸ªäººæ¨¡æ¿ï¼ŒæŸ¥çœ‹æ‰€æœ‰æ¨¡æ¿ ç³»ç»Ÿç›‘æ§ âœ… å…¨éƒ¨ âŒ ç®¡ç†å‘˜å¯æŸ¥çœ‹ç³»ç»Ÿå¥åº·çŠ¶æ€ã€QPSç­‰ ğŸ—ï¸ æŠ€æœ¯å®ç° åç«¯æƒé™æ§åˆ¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 from enum import Enum from functools import wraps from fastapi import HTTPException, Depends from fastapi.security import HTTPBearer class UserRole(Enum): ADMIN = \u0026#34;admin\u0026#34; USER = \u0026#34;user\u0026#34; class UserManager: def __init__(self): self.storage = FileStorage() def get_user(self, user_id: str) -\u0026gt; Optional[dict]: data = self.storage.read_json(\u0026#34;users.json\u0026#34;) return data.get(\u0026#34;users\u0026#34;, {}).get(user_id) def is_admin(self, user_id: str) -\u0026gt; bool: user = self.get_user(user_id) return user and user.get(\u0026#34;role\u0026#34;) == \u0026#34;admin\u0026#34; # æƒé™è£…é¥°å™¨ def require_admin(func): @wraps(func) async def wrapper(request: Request, *args, **kwargs): user_id = get_current_user_id(request) if not user_manager.is_admin(user_id): raise HTTPException(403, \u0026#34;éœ€è¦ç®¡ç†å‘˜æƒé™\u0026#34;) return await func(request, *args, **kwargs) return wrapper def require_auth(func): @wraps(func) async def wrapper(request: Request, *args, **kwargs): user_id = get_current_user_id(request) if not user_id: raise HTTPException(401, \u0026#34;éœ€è¦ç™»å½•\u0026#34;) return await func(request, *args, **kwargs) return wrapper # APIæ¥å£æƒé™æ§åˆ¶ @app.post(\u0026#34;/api/llm/add\u0026#34;) @require_admin async def add_llm(model: dict = Body(...)): \u0026#34;\u0026#34;\u0026#34;æ·»åŠ LLMæ¨¡å‹ - ä»…ç®¡ç†å‘˜\u0026#34;\u0026#34;\u0026#34; pass @app.post(\u0026#34;/api/llm/delete\u0026#34;) @require_admin async def delete_llm(model: dict = Body(...)): \u0026#34;\u0026#34;\u0026#34;åˆ é™¤LLMæ¨¡å‹ - ä»…ç®¡ç†å‘˜\u0026#34;\u0026#34;\u0026#34; pass @app.get(\u0026#34;/api/prompt/list\u0026#34;) @require_auth async def list_prompts(current_user: dict = Depends(get_current_user)): \u0026#34;\u0026#34;\u0026#34;è·å–Promptåˆ—è¡¨ - ç®¡ç†å‘˜çœ‹å…¨éƒ¨ï¼Œç”¨æˆ·çœ‹å…¨éƒ¨ï¼ˆåªè¯»ï¼‰\u0026#34;\u0026#34;\u0026#34; if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): prompts = prompt_manager.get_all_prompts() else: prompts = prompt_manager.get_all_prompts_readonly() return {\u0026#34;prompts\u0026#34;: prompts} @app.post(\u0026#34;/api/prompt/add\u0026#34;) @require_auth async def add_prompt( name: str, content: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;æ·»åŠ Prompt - ç®¡ç†å‘˜å¯æ·»åŠ ä»»ä½•ï¼Œç”¨æˆ·åªèƒ½æ·»åŠ è‡ªå·±çš„\u0026#34;\u0026#34;\u0026#34; if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): prompt_id = prompt_manager.create_prompt(name, content, None) # ç®¡ç†å‘˜å¯åˆ›å»ºå…¬å…±æ¨¡æ¿ else: prompt_id = prompt_manager.create_prompt(name, content, current_user[\u0026#34;id\u0026#34;]) return {\u0026#34;id\u0026#34;: prompt_id, \u0026#34;message\u0026#34;: \u0026#34;åˆ›å»ºæˆåŠŸ\u0026#34;} @app.delete(\u0026#34;/api/prompt/{prompt_id}\u0026#34;) @require_auth async def delete_prompt( prompt_id: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;åˆ é™¤Prompt - ç®¡ç†å‘˜å¯åˆ é™¤ä»»ä½•ï¼Œç”¨æˆ·åªèƒ½åˆ é™¤è‡ªå·±çš„\u0026#34;\u0026#34;\u0026#34; prompt = prompt_manager.get_prompt(prompt_id) if not prompt: raise HTTPException(404, \u0026#34;Promptä¸å­˜åœ¨\u0026#34;) if not user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]) and prompt[\u0026#34;user_id\u0026#34;] != current_user[\u0026#34;id\u0026#34;]: raise HTTPException(403, \u0026#34;åªèƒ½åˆ é™¤è‡ªå·±çš„Prompt\u0026#34;) prompt_manager.delete_prompt(prompt_id) return {\u0026#34;message\u0026#34;: \u0026#34;åˆ é™¤æˆåŠŸ\u0026#34;} å‰ç«¯æƒé™æ§åˆ¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // æƒé™é…ç½® const PERMISSIONS = { ADMIN: [\u0026#39;*\u0026#39;], // ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™ USER: [\u0026#39;history\u0026#39;, \u0026#39;prompt_manage\u0026#39;, \u0026#39;service_call\u0026#39;, \u0026#39;cost_view\u0026#39;] } // æƒé™æ£€æŸ¥å‡½æ•° function hasPermission(permission) { const userRole = userStore.role return PERMISSIONS[userRole].includes(\u0026#39;*\u0026#39;) || PERMISSIONS[userRole].includes(permission) } // ç”¨æˆ·çŠ¶æ€ç®¡ç† const userStore = reactive({ id: null, username: \u0026#39;\u0026#39;, role: \u0026#39;user\u0026#39;, isAuthenticated: false }) // èœå•æƒé™æ§åˆ¶ const menuItems = computed(() =\u0026gt; { const items = [ { name: \u0026#39;LLMç›‘æ§\u0026#39;, key: \u0026#39;dashboard\u0026#39;, permission: \u0026#39;cost_view\u0026#39; }, { name: \u0026#39;æœåŠ¡å‘ç°\u0026#39;, key: \u0026#39;discovery\u0026#39;, permission: \u0026#39;service_discovery\u0026#39; }, { name: \u0026#39;è°ƒç”¨å†å²\u0026#39;, key: \u0026#39;history\u0026#39;, permission: \u0026#39;history\u0026#39; }, { name: \u0026#39;LLMé…ç½®\u0026#39;, key: \u0026#39;llmconfig\u0026#39;, permission: \u0026#39;llm_config\u0026#39; }, { name: \u0026#39;Promptç®¡ç†\u0026#39;, key: \u0026#39;prompt\u0026#39;, permission: \u0026#39;prompt_manage\u0026#39; }, { name: \u0026#39;å¸®åŠ©\u0026#39;, key: \u0026#39;help\u0026#39;, permission: \u0026#39;*\u0026#39; } ] return items.filter(item =\u0026gt; hasPermission(item.permission)) }) // Promptç®¡ç†ç»„ä»¶æƒé™æ§åˆ¶ const PromptManager = { setup() { const userRole = userStore.role const isAdmin = userRole === \u0026#39;ADMIN\u0026#39; // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç¼–è¾‘Prompt const canEdit = (prompt) =\u0026gt; { return isAdmin || prompt.user_id === userStore.id } // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ é™¤Prompt const canDelete = (prompt) =\u0026gt; { return isAdmin || prompt.user_id === userStore.id } // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºPrompt const canCreate = () =\u0026gt; { return true // æ‰€æœ‰ç”¨æˆ·éƒ½å¯ä»¥åˆ›å»º } return { canEdit, canDelete, canCreate } } } ğŸ’¾ æ•°æ®å­˜å‚¨æ–¹æ¡ˆ è½»é‡çº§JSONæ–‡ä»¶å­˜å‚¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 import json import os from typing import Dict, List, Optional from datetime import datetime import threading class FileStorage: def __init__(self, data_dir: str = \u0026#34;data\u0026#34;): self.data_dir = data_dir self.lock = threading.Lock() os.makedirs(data_dir, exist_ok=True) def _get_file_path(self, filename: str) -\u0026gt; str: return os.path.join(self.data_dir, filename) def read_json(self, filename: str) -\u0026gt; dict: file_path = self._get_file_path(filename) if not os.path.exists(file_path): return {} with self.lock: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: return json.load(f) def write_json(self, filename: str, data: dict): file_path = self._get_file_path(filename) with self.lock: with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: json.dump(data, f, ensure_ascii=False, indent=2) class UserManager: def __init__(self): self.storage = FileStorage() def get_user(self, user_id: str) -\u0026gt; Optional[dict]: data = self.storage.read_json(\u0026#34;users.json\u0026#34;) return data.get(\u0026#34;users\u0026#34;, {}).get(user_id) def create_user(self, user_id: str, username: str, role: str = \u0026#34;user\u0026#34;): data = self.storage.read_json(\u0026#34;users.json\u0026#34;) if \u0026#34;users\u0026#34; not in data: data[\u0026#34;users\u0026#34;] = {} data[\u0026#34;users\u0026#34;][user_id] = { \u0026#34;id\u0026#34;: user_id, \u0026#34;username\u0026#34;: username, \u0026#34;role\u0026#34;: role, \u0026#34;created_at\u0026#34;: datetime.now().isoformat() } self.storage.write_json(\u0026#34;users.json\u0026#34;, data) def is_admin(self, user_id: str) -\u0026gt; bool: user = self.get_user(user_id) return user and user.get(\u0026#34;role\u0026#34;) == \u0026#34;admin\u0026#34; class UserPromptManager: def __init__(self): self.storage = FileStorage() self.prompt_dir = \u0026#34;config_prompts\u0026#34; # ä½¿ç”¨ç°æœ‰Promptç›®å½• def get_user_prompts(self, user_id: str) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;è·å–ç”¨æˆ·çš„Promptå…³è”ä¿¡æ¯\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) return data.get(\u0026#34;user_prompts\u0026#34;, {}).get(user_id, { \u0026#34;owned_prompts\u0026#34;: [], \u0026#34;favorite_prompts\u0026#34;: [], \u0026#34;created_at\u0026#34;: datetime.now().isoformat() }) def get_user_accessible_prompts(self, user_id: str) -\u0026gt; List[str]: \u0026#34;\u0026#34;\u0026#34;è·å–ç”¨æˆ·å¯è®¿é—®çš„Promptæ–‡ä»¶ååˆ—è¡¨\u0026#34;\u0026#34;\u0026#34; user_prompts = self.get_user_prompts(user_id) # è·å–æ‰€æœ‰Promptæ–‡ä»¶ all_prompts = [] for fname in os.listdir(self.prompt_dir): if os.path.isfile(os.path.join(self.prompt_dir, fname)): all_prompts.append(fname) # ç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰Promptæ–‡ä»¶ï¼ˆåªè¯»ï¼‰ return all_prompts def can_user_edit_prompt(self, user_id: str, prompt_filename: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥ç¼–è¾‘æŒ‡å®šPromptæ–‡ä»¶\u0026#34;\u0026#34;\u0026#34; user_prompts = self.get_user_prompts(user_id) return prompt_filename in user_prompts[\u0026#34;owned_prompts\u0026#34;] def add_user_prompt(self, user_id: str, prompt_filename: str, prompt_type: str = \u0026#34;owned\u0026#34;): \u0026#34;\u0026#34;\u0026#34;ä¸ºç”¨æˆ·æ·»åŠ Promptå…³è”\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) if \u0026#34;user_prompts\u0026#34; not in data: data[\u0026#34;user_prompts\u0026#34;] = {} if user_id not in data[\u0026#34;user_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id] = { \u0026#34;owned_prompts\u0026#34;: [], \u0026#34;favorite_prompts\u0026#34;: [], \u0026#34;created_at\u0026#34;: datetime.now().isoformat() } if prompt_type == \u0026#34;owned\u0026#34;: if prompt_filename not in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;].append(prompt_filename) elif prompt_type == \u0026#34;favorite\u0026#34;: if prompt_filename not in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;].append(prompt_filename) self.storage.write_json(\u0026#34;user_prompts.json\u0026#34;, data) def remove_user_prompt(self, user_id: str, prompt_filename: str, prompt_type: str = \u0026#34;owned\u0026#34;): \u0026#34;\u0026#34;\u0026#34;ç§»é™¤ç”¨æˆ·çš„Promptå…³è”\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) if user_id in data.get(\u0026#34;user_prompts\u0026#34;, {}): if prompt_type == \u0026#34;owned\u0026#34;: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;] = [ p for p in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;] if p != prompt_filename ] elif prompt_type == \u0026#34;favorite\u0026#34;: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;] = [ p for p in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;] if p != prompt_filename ] self.storage.write_json(\u0026#34;user_prompts.json\u0026#34;, data) # ä¿æŒç°æœ‰PromptManagerä¸å˜ï¼Œç”¨äºå…¼å®¹ç°æœ‰ç³»ç»Ÿ class PromptManager: def __init__(self, prompt_dir=\u0026#34;config_prompts\u0026#34;): self.prompts = {} if not os.path.exists(prompt_dir): return for fname in os.listdir(prompt_dir): fpath = os.path.join(prompt_dir, fname) if fname.endswith(\u0026#34;.yaml\u0026#34;) or fname.endswith(\u0026#34;.yml\u0026#34;): with open(fpath, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: self.prompts[fname[:-5]] = yaml.safe_load(f) elif fname.endswith(\u0026#34;.json\u0026#34;): with open(fpath, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: self.prompts[fname[:-5]] = json.load(f) elif fname.endswith(\u0026#34;.ini\u0026#34;): cp = configparser.ConfigParser() cp.read(fpath, encoding=\u0026#34;utf-8\u0026#34;) self.prompts[fname[:-4]] = {s: dict(cp.items(s)) for s in cp.sections()} def get_prompt(self, plugin, template=\u0026#34;default\u0026#34;): # plugin: æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰ï¼Œtemplate: section/key p = self.prompts.get(plugin, {}) if isinstance(p, dict): return p.get(template, \u0026#34;\u0026#34;) return p æ•°æ®æ–‡ä»¶ç»“æ„ 1 2 3 4 5 6 7 8 9 10 11 data/ â”œâ”€â”€ users.json # ç”¨æˆ·æ•°æ® â”œâ”€â”€ user_prompts.json # ç”¨æˆ·ä¸Promptçš„å…³è”å…³ç³» â”œâ”€â”€ history.json # è°ƒç”¨å†å² â””â”€â”€ llm_config.json # LLMé…ç½® config_prompts/ # ç°æœ‰Promptæ¨¡æ¿å­˜å‚¨ç›®å½•ï¼ˆä¿æŒä¸å˜ï¼‰ â”œâ”€â”€ prompt.ini # ç°æœ‰Promptæ–‡ä»¶ â”œâ”€â”€ prom # ç°æœ‰Promptæ–‡ä»¶ â”œâ”€â”€ prompt_x.ini # ç°æœ‰Promptæ–‡ä»¶ â””â”€â”€ ... # å…¶ä»–ç°æœ‰Promptæ–‡ä»¶ users.json ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;users\u0026#34;: { \u0026#34;admin1\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;admin1\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;ç³»ç»Ÿç®¡ç†å‘˜\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T10:00:00Z\u0026#34; }, \u0026#34;user1\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;user1\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;å¼ ä¸‰\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T11:00:00Z\u0026#34; } } } user_prompts.json ç¤ºä¾‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;user_prompts\u0026#34;: { \u0026#34;user1\u0026#34;: { \u0026#34;owned_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;, \u0026#34;custom_prompt.yaml\u0026#34;], \u0026#34;favorite_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;], \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T10:00:00Z\u0026#34; }, \u0026#34;user2\u0026#34;: { \u0026#34;owned_prompts\u0026#34;: [\u0026#34;my_prompt.json\u0026#34;], \u0026#34;favorite_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;, \u0026#34;prompt_x.ini\u0026#34;], \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T11:00:00Z\u0026#34; } } } ğŸ” è®¤è¯æœºåˆ¶ ç®€åŒ–è®¤è¯æ–¹æ¡ˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 from fastapi import HTTPException, Depends from fastapi.security import HTTPBearer security = HTTPBearer() def get_current_user(token: str = Depends(security)): # ç®€åŒ–å¤„ç†ï¼štokenç›´æ¥ä½œä¸ºuser_id # å®é™…é¡¹ç›®ä¸­åº”ä½¿ç”¨JWTæˆ–å…¶ä»–è®¤è¯æ–¹å¼ user_id = token.credentials user = user_manager.get_user(user_id) if not user: raise HTTPException(401, \u0026#34;ç”¨æˆ·ä¸å­˜åœ¨\u0026#34;) return user # ç™»å½•æ¥å£ @app.post(\u0026#34;/api/login\u0026#34;) async def login(username: str, password: str): # ç®€åŒ–å¤„ç†ï¼šç›´æ¥è¿”å›ç”¨æˆ·ä¿¡æ¯ # å®é™…é¡¹ç›®ä¸­éœ€è¦éªŒè¯å¯†ç  user = user_manager.get_user_by_username(username) if not user: raise HTTPException(401, \u0026#34;ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯\u0026#34;) return { \u0026#34;user_id\u0026#34;: user[\u0026#34;id\u0026#34;], \u0026#34;username\u0026#34;: user[\u0026#34;username\u0026#34;], \u0026#34;role\u0026#34;: user[\u0026#34;role\u0026#34;], \u0026#34;token\u0026#34;: user[\u0026#34;id\u0026#34;] # ç®€åŒ–å¤„ç† } # Promptç®¡ç†APIæ¥å£ @app.get(\u0026#34;/api/prompt/list\u0026#34;) @require_auth async def list_prompts(current_user: dict = Depends(get_current_user)): \u0026#34;\u0026#34;\u0026#34;è·å–Promptåˆ—è¡¨ - å…¼å®¹ç°æœ‰ç³»ç»Ÿ\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): # ç®¡ç†å‘˜çœ‹åˆ°æ‰€æœ‰Promptæ–‡ä»¶ prompt_files = user_prompt_manager.get_user_accessible_prompts(current_user[\u0026#34;id\u0026#34;]) else: # æ™®é€šç”¨æˆ·çœ‹åˆ°æ‰€æœ‰Promptæ–‡ä»¶ï¼ˆåªè¯»ï¼‰ prompt_files = user_prompt_manager.get_user_accessible_prompts(current_user[\u0026#34;id\u0026#34;]) # è¿”å›æ–‡ä»¶ååˆ—è¡¨ï¼Œå…¼å®¹ç°æœ‰API return {\u0026#34;files\u0026#34;: prompt_files} @app.post(\u0026#34;/api/prompt/new\u0026#34;) @require_auth async def new_prompt_file( name: str = Body(...), content: str = Body(...), current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;åˆ›å»ºæ–°Promptæ–‡ä»¶\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨ file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, name) if os.path.exists(file_path): raise HTTPException(409, \u0026#34;æ–‡ä»¶å·²å­˜åœ¨\u0026#34;) # åˆ›å»ºæ–‡ä»¶ with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(content) # å°†æ–‡ä»¶å…³è”åˆ°ç”¨æˆ· user_prompt_manager.add_user_prompt(current_user[\u0026#34;id\u0026#34;], name, \u0026#34;owned\u0026#34;) return {\u0026#34;status\u0026#34;: \u0026#34;created\u0026#34;, \u0026#34;name\u0026#34;: name} @app.post(\u0026#34;/api/prompt/file\u0026#34;) @require_auth async def save_prompt_file( name: str = Body(...), content: str = Body(...), current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;ä¿å­˜Promptæ–‡ä»¶ - åªèƒ½ç¼–è¾‘è‡ªå·±çš„æ–‡ä»¶\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() if not user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): if not user_prompt_manager.can_user_edit_prompt(current_user[\u0026#34;id\u0026#34;], name): raise HTTPException(403, \u0026#34;åªèƒ½ç¼–è¾‘è‡ªå·±çš„Promptæ–‡ä»¶\u0026#34;) # ä¿å­˜æ–‡ä»¶ file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, name) with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(content) return {\u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;name\u0026#34;: name} @app.post(\u0026#34;/api/prompt/favorite/{prompt_filename}\u0026#34;) @require_auth async def favorite_prompt( prompt_filename: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;æ”¶è—Promptæ–‡ä»¶\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() user_prompt_manager.add_user_prompt(current_user[\u0026#34;id\u0026#34;], prompt_filename, \u0026#34;favorite\u0026#34;) return {\u0026#34;message\u0026#34;: \u0026#34;æ”¶è—æˆåŠŸ\u0026#34;} @app.delete(\u0026#34;/api/prompt/{prompt_filename}\u0026#34;) @require_auth async def delete_prompt( prompt_filename: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;åˆ é™¤Promptæ–‡ä»¶ - åªèƒ½åˆ é™¤è‡ªå·±æ‹¥æœ‰çš„\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() user_prompts = user_prompt_manager.get_user_prompts(current_user[\u0026#34;id\u0026#34;]) if prompt_filename not in user_prompts[\u0026#34;owned_prompts\u0026#34;]: raise HTTPException(403, \u0026#34;åªèƒ½åˆ é™¤è‡ªå·±çš„Promptæ–‡ä»¶\u0026#34;) # åˆ é™¤æ–‡ä»¶ file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, prompt_filename) if os.path.exists(file_path): os.remove(file_path) # ç§»é™¤ç”¨æˆ·å…³è” user_prompt_manager.remove_user_prompt(current_user[\u0026#34;id\u0026#34;], prompt_filename, \u0026#34;owned\u0026#34;) return {\u0026#34;message\u0026#34;: \u0026#34;åˆ é™¤æˆåŠŸ\u0026#34;} ğŸ“± å‰ç«¯ç•Œé¢é€‚é… ç”¨æˆ·è§’è‰²æ˜¾ç¤º 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;user-info\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ userStore.username }}\u0026lt;/span\u0026gt; \u0026lt;el-tag :type=\u0026#34;userStore.role === \u0026#39;admin\u0026#39; ? \u0026#39;danger\u0026#39; : \u0026#39;primary\u0026#39;\u0026#34;\u0026gt; {{ userStore.role === \u0026#39;admin\u0026#39; ? \u0026#39;ç®¡ç†å‘˜\u0026#39; : \u0026#39;ç”¨æˆ·\u0026#39; }} \u0026lt;/el-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; æƒé™æ§åˆ¶ç»„ä»¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- åªæœ‰ç®¡ç†å‘˜å¯è§ --\u0026gt; \u0026lt;div v-if=\u0026#34;hasPermission(\u0026#39;user_manage\u0026#39;)\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;manageUsers\u0026#34;\u0026gt;ç”¨æˆ·ç®¡ç†\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- æ‰€æœ‰ç”¨æˆ·å¯è§ --\u0026gt; \u0026lt;div v-if=\u0026#34;hasPermission(\u0026#39;prompt_manage\u0026#39;)\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;createPrompt\u0026#34;\u0026gt;åˆ›å»ºPrompt\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { computed } from \u0026#39;vue\u0026#39; import { useUserStore } from \u0026#39;@/stores/user\u0026#39; const userStore = useUserStore() const hasPermission = (permission) =\u0026gt; { return userStore.hasPermission(permission) } \u0026lt;/script\u0026gt; ğŸš€ éƒ¨ç½²å’Œé…ç½® åˆå§‹åŒ–è„šæœ¬ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # init_users.py from user_manager import UserManager def init_default_users(): user_manager = UserManager() # åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜ user_manager.create_user( user_id=\u0026#34;admin\u0026#34;, username=\u0026#34;ç³»ç»Ÿç®¡ç†å‘˜\u0026#34;, role=\u0026#34;admin\u0026#34; ) # åˆ›å»ºé»˜è®¤ç”¨æˆ· user_manager.create_user( user_id=\u0026#34;user1\u0026#34;, username=\u0026#34;æµ‹è¯•ç”¨æˆ·\u0026#34;, role=\u0026#34;user\u0026#34; ) print(\u0026#34;é»˜è®¤ç”¨æˆ·åˆ›å»ºå®Œæˆ\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: init_default_users() é…ç½®æ–‡ä»¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 # config.py class Config: # æ•°æ®å­˜å‚¨è·¯å¾„ DATA_DIR = \u0026#34;data\u0026#34; # é»˜è®¤ç”¨æˆ·è§’è‰² DEFAULT_USER_ROLE = \u0026#34;user\u0026#34; # æƒé™é…ç½® PERMISSIONS = { \u0026#34;admin\u0026#34;: [\u0026#34;*\u0026#34;], \u0026#34;user\u0026#34;: [\u0026#34;history\u0026#34;, \u0026#34;prompt_manage\u0026#34;, \u0026#34;service_call\u0026#34;, \u0026#34;cost_view\u0026#34;] } ğŸ“ˆ å‡çº§è·¯å¾„ å½“å‰æ–¹æ¡ˆä¼˜åŠ¿ ç®€å•æ˜“ç”¨ï¼šä¸¤çº§æƒé™ï¼Œé€»è¾‘æ¸…æ™° å¿«é€Ÿéƒ¨ç½²ï¼šJSONæ–‡ä»¶å­˜å‚¨ï¼Œé›¶ä¾èµ– æˆæœ¬ä½å»‰ï¼šæ— éœ€æ•°æ®åº“ï¼Œç»´æŠ¤ç®€å• æ˜“äºæ‰©å±•ï¼šä¸ºåç»­å‡çº§é¢„ç•™ç©ºé—´ å®Œå…¨å…¼å®¹ï¼šä¿æŒç°æœ‰Promptå­˜å‚¨æ–¹å¼ä¸å˜ æœªæ¥å‡çº§æ–¹å‘ 1 2 3 4 5 å½“å‰ï¼šJSONæ–‡ä»¶ + ä¸¤çº§æƒé™ + ç°æœ‰Promptå­˜å‚¨ â†“ ä¸­æœŸï¼šSQLite + ä¸‰çº§æƒé™ï¼ˆå¢åŠ å¼€å‘è€…è§’è‰²ï¼‰ â†“ é•¿æœŸï¼šMySQL + å››çº§æƒé™ï¼ˆå®Œæ•´ä¼ä¸šçº§æƒé™ä½“ç³»ï¼‰ å…¼å®¹æ€§è¯´æ˜ ç°æœ‰Promptç³»ç»Ÿï¼šå®Œå…¨ä¿æŒä¸å˜ï¼Œç»§ç»­ä½¿ç”¨ config_prompts/ ç›®å½• ç”¨æˆ·æƒé™ç®¡ç†ï¼šé€šè¿‡ user_prompts.json ç®¡ç†ç”¨æˆ·ä¸Promptçš„å…³è”å…³ç³» APIæ¥å£ï¼šå…¼å®¹ç°æœ‰çš„Prompt APIï¼ŒåŒæ—¶å¢åŠ æƒé™æ§åˆ¶ ä¸šåŠ¡é€»è¾‘ï¼šç°æœ‰ä¸šåŠ¡ä»£ç æ— éœ€ä¿®æ”¹ï¼Œæƒé™æ§åˆ¶åœ¨APIå±‚å®ç° âœ… å®æ–½æ£€æŸ¥æ¸…å• åç«¯å¼€å‘ å®ç°FileStorageç±» å®ç°UserManagerç±» å®ç°UserPromptManagerç±»ï¼ˆæ–°å¢ï¼‰ ä¿æŒç°æœ‰PromptManagerç±»ä¸å˜ æ·»åŠ æƒé™è£…é¥°å™¨ ä¿®æ”¹APIæ¥å£æ”¯æŒæƒé™æ§åˆ¶ å®ç°è®¤è¯æœºåˆ¶ ç¡®ä¿ä¸ç°æœ‰Prompt APIå…¼å®¹ å‰ç«¯å¼€å‘ å®ç°ç”¨æˆ·çŠ¶æ€ç®¡ç† æ·»åŠ æƒé™æ£€æŸ¥å‡½æ•° ä¿®æ”¹èœå•æ˜¾ç¤ºé€»è¾‘ é€‚é…Promptç®¡ç†ç•Œé¢ æ·»åŠ ç”¨æˆ·è§’è‰²æ˜¾ç¤º æµ‹è¯•éªŒè¯ ç®¡ç†å‘˜æƒé™æµ‹è¯• æ™®é€šç”¨æˆ·æƒé™æµ‹è¯• Promptç®¡ç†åŠŸèƒ½æµ‹è¯• æ•°æ®éš”ç¦»æµ‹è¯• æƒé™å‡çº§æµ‹è¯• ç°æœ‰Promptç³»ç»Ÿå…¼å®¹æ€§æµ‹è¯• ç”¨æˆ·Promptå…³è”å…³ç³»æµ‹è¯• æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0\nåˆ›å»ºæ—¶é—´ï¼š2025å¹´7æœˆ\né€‚ç”¨åœºæ™¯ï¼šå°å‹ä¼ä¸šï¼ˆ\u0026lt; 50äººï¼‰\næŠ€æœ¯æ ˆï¼šFastAPI + Vue.js + JSONæ–‡ä»¶å­˜å‚¨\n","date":"2025-07-31T18:22:48+08:00","permalink":"https://zhangzib123.github.io/p/aicorehub-%E4%B8%A4%E7%BA%A7%E7%94%A8%E6%88%B7%E4%BD%93%E7%B3%BB%E8%AE%BE%E8%AE%A1/","title":"AICoreHub ä¸¤çº§ç”¨æˆ·ä½“ç³»è®¾è®¡"},{"content":"æ–‡ç« æ ‡é¢˜ æ–‡ç« å†…å®¹111\n","date":"2025-07-31T15:22:48+08:00","permalink":"https://zhangzib123.github.io/p/abc/","title":"Abc"}]