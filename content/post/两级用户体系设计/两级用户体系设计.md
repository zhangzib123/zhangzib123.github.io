+++

date = '2025-07-31T18:22:48+08:00' 

title = 'AICoreHub ä¸¤çº§ç”¨æˆ·ä½“ç³»è®¾è®¡' 

+++







# AICoreHub ä¸¤çº§ç”¨æˆ·ä½“ç³»è®¾è®¡

## ğŸ“‹ æ¦‚è¿°

åŸºäºAICoreHubä½œä¸º"ä¼ä¸šAIèƒ½åŠ›çš„æ€»çº¿ä¸ä¸­æ¢"çš„å®šä½ï¼Œé‡‡ç”¨**ä¸¤çº§ç”¨æˆ·ä½“ç³»**ï¼Œæ—¢æ»¡è¶³å°å‹ä¼ä¸šçš„ç®¡ç†éœ€æ±‚ï¼Œåˆä¿æŒç³»ç»Ÿçš„ç®€æ´æ€§å’Œæ˜“ç”¨æ€§ã€‚

## ğŸ¯ ç”¨æˆ·åˆ†çº§

### 1. **ç®¡ç†å‘˜ (Admin)**
- **æƒé™èŒƒå›´**ï¼šç³»ç»Ÿçº§å®Œå…¨ç®¡ç†
- **å…¸å‹ç”¨æˆ·**ï¼šITè´Ÿè´£äººã€ç³»ç»Ÿç®¡ç†å‘˜ã€æŠ€æœ¯ä¸»ç®¡
- **ä¸»è¦èŒè´£**ï¼š
  - ç”¨æˆ·è´¦æˆ·ç®¡ç†
  - LLMæ¨¡å‹é…ç½®ç®¡ç†
  - ç³»ç»Ÿç›‘æ§å’Œç»´æŠ¤
  - å…¨å±€æ•°æ®æŸ¥çœ‹

### 2. **æ™®é€šç”¨æˆ· (User)**
- **æƒé™èŒƒå›´**ï¼šä¸ªäººä½¿ç”¨æƒé™
- **å…¸å‹ç”¨æˆ·**ï¼šå¼€å‘å·¥ç¨‹å¸ˆã€ä¸šåŠ¡äººå‘˜ã€å®¢æœã€å¸‚åœºäººå‘˜
- **ä¸»è¦èŒè´£**ï¼š
  - ä¸ªäººPromptæ¨¡æ¿ç®¡ç†
  - æœåŠ¡è°ƒç”¨å’Œæµ‹è¯•
  - ä¸ªäººæ•°æ®æŸ¥çœ‹

## ğŸ“Š æƒé™çŸ©é˜µ

| åŠŸèƒ½æ¨¡å— | Admin | User | è¯´æ˜ |
|---------|-------|------|------|
| **ç”¨æˆ·ç®¡ç†** | âœ… å¢åˆ æ”¹æŸ¥ | âŒ | ç®¡ç†å‘˜å¯åˆ›å»ºã€åˆ é™¤ã€ä¿®æ”¹ç”¨æˆ·è´¦æˆ· |
| **LLMé…ç½®** | âœ… å¢åˆ æ”¹æŸ¥ | âœ… æŸ¥çœ‹ | ç®¡ç†å‘˜å¯é…ç½®ã€ç®¡ç†æ‰€æœ‰LLMæ¨¡å‹ |
| **æœåŠ¡å‘ç°** | âœ… å…¨éƒ¨ | âœ… æŸ¥çœ‹ | æ‰€æœ‰ç”¨æˆ·å¯æŸ¥çœ‹æœåŠ¡åˆ—è¡¨ |
| **è°ƒç”¨å†å²** | âœ… å…¨éƒ¨ | âœ… ä¸ªäºº | ç®¡ç†å‘˜çœ‹å…¨éƒ¨ï¼Œç”¨æˆ·åªçœ‹è‡ªå·±çš„ |
| **æˆæœ¬ç›‘æ§** | âœ… å…¨éƒ¨ | âœ… ä¸ªäºº | ç®¡ç†å‘˜çœ‹å…¨å±€æˆæœ¬ï¼Œç”¨æˆ·çœ‹ä¸ªäººæˆæœ¬ |
| **Promptç®¡ç†** | âœ… å¢åˆ æ”¹æŸ¥æ‰€æœ‰ | âœ… å¢åˆ æ”¹è‡ªå·±çš„ï¼ŒæŸ¥çœ‹æ‰€æœ‰ | ç”¨æˆ·å¯åˆ›å»ºä¸ªäººæ¨¡æ¿ï¼ŒæŸ¥çœ‹æ‰€æœ‰æ¨¡æ¿ |
| **ç³»ç»Ÿç›‘æ§** | âœ… å…¨éƒ¨ | âŒ | ç®¡ç†å‘˜å¯æŸ¥çœ‹ç³»ç»Ÿå¥åº·çŠ¶æ€ã€QPSç­‰ |

## ğŸ—ï¸ æŠ€æœ¯å®ç°

### åç«¯æƒé™æ§åˆ¶

```python
from enum import Enum
from functools import wraps
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer

class UserRole(Enum):
    ADMIN = "admin"
    USER = "user"

class UserManager:
    def __init__(self):
        self.storage = FileStorage()
    
    def get_user(self, user_id: str) -> Optional[dict]:
        data = self.storage.read_json("users.json")
        return data.get("users", {}).get(user_id)
    
    def is_admin(self, user_id: str) -> bool:
        user = self.get_user(user_id)
        return user and user.get("role") == "admin"

# æƒé™è£…é¥°å™¨
def require_admin(func):
    @wraps(func)
    async def wrapper(request: Request, *args, **kwargs):
        user_id = get_current_user_id(request)
        if not user_manager.is_admin(user_id):
            raise HTTPException(403, "éœ€è¦ç®¡ç†å‘˜æƒé™")
        return await func(request, *args, **kwargs)
    return wrapper

def require_auth(func):
    @wraps(func)
    async def wrapper(request: Request, *args, **kwargs):
        user_id = get_current_user_id(request)
        if not user_id:
            raise HTTPException(401, "éœ€è¦ç™»å½•")
        return await func(request, *args, **kwargs)
    return wrapper

# APIæ¥å£æƒé™æ§åˆ¶
@app.post("/api/llm/add")
@require_admin
async def add_llm(model: dict = Body(...)):
    """æ·»åŠ LLMæ¨¡å‹ - ä»…ç®¡ç†å‘˜"""
    pass

@app.post("/api/llm/delete")
@require_admin
async def delete_llm(model: dict = Body(...)):
    """åˆ é™¤LLMæ¨¡å‹ - ä»…ç®¡ç†å‘˜"""
    pass

@app.get("/api/prompt/list")
@require_auth
async def list_prompts(current_user: dict = Depends(get_current_user)):
    """è·å–Promptåˆ—è¡¨ - ç®¡ç†å‘˜çœ‹å…¨éƒ¨ï¼Œç”¨æˆ·çœ‹å…¨éƒ¨ï¼ˆåªè¯»ï¼‰"""
    if user_manager.is_admin(current_user["id"]):
        prompts = prompt_manager.get_all_prompts()
    else:
        prompts = prompt_manager.get_all_prompts_readonly()
    return {"prompts": prompts}

@app.post("/api/prompt/add")
@require_auth
async def add_prompt(
    name: str,
    content: str,
    current_user: dict = Depends(get_current_user)
):
    """æ·»åŠ Prompt - ç®¡ç†å‘˜å¯æ·»åŠ ä»»ä½•ï¼Œç”¨æˆ·åªèƒ½æ·»åŠ è‡ªå·±çš„"""
    if user_manager.is_admin(current_user["id"]):
        prompt_id = prompt_manager.create_prompt(name, content, None)  # ç®¡ç†å‘˜å¯åˆ›å»ºå…¬å…±æ¨¡æ¿
    else:
        prompt_id = prompt_manager.create_prompt(name, content, current_user["id"])
    return {"id": prompt_id, "message": "åˆ›å»ºæˆåŠŸ"}

@app.delete("/api/prompt/{prompt_id}")
@require_auth
async def delete_prompt(
    prompt_id: str,
    current_user: dict = Depends(get_current_user)
):
    """åˆ é™¤Prompt - ç®¡ç†å‘˜å¯åˆ é™¤ä»»ä½•ï¼Œç”¨æˆ·åªèƒ½åˆ é™¤è‡ªå·±çš„"""
    prompt = prompt_manager.get_prompt(prompt_id)
    if not prompt:
        raise HTTPException(404, "Promptä¸å­˜åœ¨")
    
    if not user_manager.is_admin(current_user["id"]) and prompt["user_id"] != current_user["id"]:
        raise HTTPException(403, "åªèƒ½åˆ é™¤è‡ªå·±çš„Prompt")
    
    prompt_manager.delete_prompt(prompt_id)
    return {"message": "åˆ é™¤æˆåŠŸ"}
```

### å‰ç«¯æƒé™æ§åˆ¶

```javascript
// æƒé™é…ç½®
const PERMISSIONS = {
  ADMIN: ['*'],  // ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
  USER: ['history', 'prompt_manage', 'service_call', 'cost_view']
}

// æƒé™æ£€æŸ¥å‡½æ•°
function hasPermission(permission) {
  const userRole = userStore.role
  return PERMISSIONS[userRole].includes('*') || 
         PERMISSIONS[userRole].includes(permission)
}

// ç”¨æˆ·çŠ¶æ€ç®¡ç†
const userStore = reactive({
  id: null,
  username: '',
  role: 'user',
  isAuthenticated: false
})

// èœå•æƒé™æ§åˆ¶
const menuItems = computed(() => {
  const items = [
    { name: 'LLMç›‘æ§', key: 'dashboard', permission: 'cost_view' },
    { name: 'æœåŠ¡å‘ç°', key: 'discovery', permission: 'service_discovery' },
    { name: 'è°ƒç”¨å†å²', key: 'history', permission: 'history' },
    { name: 'LLMé…ç½®', key: 'llmconfig', permission: 'llm_config' },
    { name: 'Promptç®¡ç†', key: 'prompt', permission: 'prompt_manage' },
    { name: 'å¸®åŠ©', key: 'help', permission: '*' }
  ]
  
  return items.filter(item => hasPermission(item.permission))
})

// Promptç®¡ç†ç»„ä»¶æƒé™æ§åˆ¶
const PromptManager = {
  setup() {
    const userRole = userStore.role
    const isAdmin = userRole === 'ADMIN'
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç¼–è¾‘Prompt
    const canEdit = (prompt) => {
      return isAdmin || prompt.user_id === userStore.id
    }
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ é™¤Prompt
    const canDelete = (prompt) => {
      return isAdmin || prompt.user_id === userStore.id
    }
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºPrompt
    const canCreate = () => {
      return true  // æ‰€æœ‰ç”¨æˆ·éƒ½å¯ä»¥åˆ›å»º
    }
    
    return { canEdit, canDelete, canCreate }
  }
}
```

## ğŸ’¾ æ•°æ®å­˜å‚¨æ–¹æ¡ˆ

### è½»é‡çº§JSONæ–‡ä»¶å­˜å‚¨

```python
import json
import os
from typing import Dict, List, Optional
from datetime import datetime
import threading

class FileStorage:
    def __init__(self, data_dir: str = "data"):
        self.data_dir = data_dir
        self.lock = threading.Lock()
        os.makedirs(data_dir, exist_ok=True)
        
    def _get_file_path(self, filename: str) -> str:
        return os.path.join(self.data_dir, filename)
    
    def read_json(self, filename: str) -> dict:
        file_path = self._get_file_path(filename)
        if not os.path.exists(file_path):
            return {}
        
        with self.lock:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
    
    def write_json(self, filename: str, data: dict):
        file_path = self._get_file_path(filename)
        with self.lock:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)

class UserManager:
    def __init__(self):
        self.storage = FileStorage()
    
    def get_user(self, user_id: str) -> Optional[dict]:
        data = self.storage.read_json("users.json")
        return data.get("users", {}).get(user_id)
    
    def create_user(self, user_id: str, username: str, role: str = "user"):
        data = self.storage.read_json("users.json")
        if "users" not in data:
            data["users"] = {}
        
        data["users"][user_id] = {
            "id": user_id,
            "username": username,
            "role": role,
            "created_at": datetime.now().isoformat()
        }
        
        self.storage.write_json("users.json", data)
    
    def is_admin(self, user_id: str) -> bool:
        user = self.get_user(user_id)
        return user and user.get("role") == "admin"

class UserPromptManager:
    def __init__(self):
        self.storage = FileStorage()
        self.prompt_dir = "config_prompts"  # ä½¿ç”¨ç°æœ‰Promptç›®å½•
    
    def get_user_prompts(self, user_id: str) -> dict:
        """è·å–ç”¨æˆ·çš„Promptå…³è”ä¿¡æ¯"""
        data = self.storage.read_json("user_prompts.json")
        return data.get("user_prompts", {}).get(user_id, {
            "owned_prompts": [],
            "favorite_prompts": [],
            "created_at": datetime.now().isoformat()
        })
    
    def get_user_accessible_prompts(self, user_id: str) -> List[str]:
        """è·å–ç”¨æˆ·å¯è®¿é—®çš„Promptæ–‡ä»¶ååˆ—è¡¨"""
        user_prompts = self.get_user_prompts(user_id)
        
        # è·å–æ‰€æœ‰Promptæ–‡ä»¶
        all_prompts = []
        for fname in os.listdir(self.prompt_dir):
            if os.path.isfile(os.path.join(self.prompt_dir, fname)):
                all_prompts.append(fname)
        
        # ç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰Promptæ–‡ä»¶ï¼ˆåªè¯»ï¼‰
        return all_prompts
    
    def can_user_edit_prompt(self, user_id: str, prompt_filename: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥ç¼–è¾‘æŒ‡å®šPromptæ–‡ä»¶"""
        user_prompts = self.get_user_prompts(user_id)
        return prompt_filename in user_prompts["owned_prompts"]
    
    def add_user_prompt(self, user_id: str, prompt_filename: str, prompt_type: str = "owned"):
        """ä¸ºç”¨æˆ·æ·»åŠ Promptå…³è”"""
        data = self.storage.read_json("user_prompts.json")
        if "user_prompts" not in data:
            data["user_prompts"] = {}
        
        if user_id not in data["user_prompts"]:
            data["user_prompts"][user_id] = {
                "owned_prompts": [],
                "favorite_prompts": [],
                "created_at": datetime.now().isoformat()
            }
        
        if prompt_type == "owned":
            if prompt_filename not in data["user_prompts"][user_id]["owned_prompts"]:
                data["user_prompts"][user_id]["owned_prompts"].append(prompt_filename)
        elif prompt_type == "favorite":
            if prompt_filename not in data["user_prompts"][user_id]["favorite_prompts"]:
                data["user_prompts"][user_id]["favorite_prompts"].append(prompt_filename)
        
        self.storage.write_json("user_prompts.json", data)
    
    def remove_user_prompt(self, user_id: str, prompt_filename: str, prompt_type: str = "owned"):
        """ç§»é™¤ç”¨æˆ·çš„Promptå…³è”"""
        data = self.storage.read_json("user_prompts.json")
        if user_id in data.get("user_prompts", {}):
            if prompt_type == "owned":
                data["user_prompts"][user_id]["owned_prompts"] = [
                    p for p in data["user_prompts"][user_id]["owned_prompts"] 
                    if p != prompt_filename
                ]
            elif prompt_type == "favorite":
                data["user_prompts"][user_id]["favorite_prompts"] = [
                    p for p in data["user_prompts"][user_id]["favorite_prompts"] 
                    if p != prompt_filename
                ]
            self.storage.write_json("user_prompts.json", data)

# ä¿æŒç°æœ‰PromptManagerä¸å˜ï¼Œç”¨äºå…¼å®¹ç°æœ‰ç³»ç»Ÿ
class PromptManager:
    def __init__(self, prompt_dir="config_prompts"):
        self.prompts = {}
        if not os.path.exists(prompt_dir):
            return
        for fname in os.listdir(prompt_dir):
            fpath = os.path.join(prompt_dir, fname)
            if fname.endswith(".yaml") or fname.endswith(".yml"):
                with open(fpath, "r", encoding="utf-8") as f:
                    self.prompts[fname[:-5]] = yaml.safe_load(f)
            elif fname.endswith(".json"):
                with open(fpath, "r", encoding="utf-8") as f:
                    self.prompts[fname[:-5]] = json.load(f)
            elif fname.endswith(".ini"):
                cp = configparser.ConfigParser()
                cp.read(fpath, encoding="utf-8")
                self.prompts[fname[:-4]] = {s: dict(cp.items(s)) for s in cp.sections()}
    
    def get_prompt(self, plugin, template="default"):
        # plugin: æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰ï¼Œtemplate: section/key
        p = self.prompts.get(plugin, {})
        if isinstance(p, dict):
            return p.get(template, "")
        return p
```

### æ•°æ®æ–‡ä»¶ç»“æ„

```
data/
â”œâ”€â”€ users.json              # ç”¨æˆ·æ•°æ®
â”œâ”€â”€ user_prompts.json       # ç”¨æˆ·ä¸Promptçš„å…³è”å…³ç³»
â”œâ”€â”€ history.json            # è°ƒç”¨å†å²
â””â”€â”€ llm_config.json         # LLMé…ç½®

config_prompts/             # ç°æœ‰Promptæ¨¡æ¿å­˜å‚¨ç›®å½•ï¼ˆä¿æŒä¸å˜ï¼‰
â”œâ”€â”€ prompt.ini              # ç°æœ‰Promptæ–‡ä»¶
â”œâ”€â”€ prom                    # ç°æœ‰Promptæ–‡ä»¶
â”œâ”€â”€ prompt_x.ini            # ç°æœ‰Promptæ–‡ä»¶
â””â”€â”€ ...                     # å…¶ä»–ç°æœ‰Promptæ–‡ä»¶
```

#### users.json ç¤ºä¾‹
```json
{
  "users": {
    "admin1": {
      "id": "admin1",
      "username": "ç³»ç»Ÿç®¡ç†å‘˜",
      "role": "admin",
      "created_at": "2025-07-01T10:00:00Z"
    },
    "user1": {
      "id": "user1",
      "username": "å¼ ä¸‰",
      "role": "user",
      "created_at": "2025-07-01T11:00:00Z"
    }
  }
}
```

#### user_prompts.json ç¤ºä¾‹
```json
{
  "user_prompts": {
    "user1": {
      "owned_prompts": ["prompt.ini", "custom_prompt.yaml"],
      "favorite_prompts": ["prompt.ini"],
      "created_at": "2025-07-01T10:00:00Z"
    },
    "user2": {
      "owned_prompts": ["my_prompt.json"],
      "favorite_prompts": ["prompt.ini", "prompt_x.ini"],
      "created_at": "2025-07-01T11:00:00Z"
    }
  }
}
```

## ğŸ” è®¤è¯æœºåˆ¶

### ç®€åŒ–è®¤è¯æ–¹æ¡ˆ

```python
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer

security = HTTPBearer()

def get_current_user(token: str = Depends(security)):
    # ç®€åŒ–å¤„ç†ï¼štokenç›´æ¥ä½œä¸ºuser_id
    # å®é™…é¡¹ç›®ä¸­åº”ä½¿ç”¨JWTæˆ–å…¶ä»–è®¤è¯æ–¹å¼
    user_id = token.credentials
    user = user_manager.get_user(user_id)
    if not user:
        raise HTTPException(401, "ç”¨æˆ·ä¸å­˜åœ¨")
    return user

# ç™»å½•æ¥å£
@app.post("/api/login")
async def login(username: str, password: str):
    # ç®€åŒ–å¤„ç†ï¼šç›´æ¥è¿”å›ç”¨æˆ·ä¿¡æ¯
    # å®é™…é¡¹ç›®ä¸­éœ€è¦éªŒè¯å¯†ç 
    user = user_manager.get_user_by_username(username)
    if not user:
        raise HTTPException(401, "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
    
    return {
        "user_id": user["id"],
        "username": user["username"],
        "role": user["role"],
        "token": user["id"]  # ç®€åŒ–å¤„ç†
    }

# Promptç®¡ç†APIæ¥å£
@app.get("/api/prompt/list")
@require_auth
async def list_prompts(current_user: dict = Depends(get_current_user)):
    """è·å–Promptåˆ—è¡¨ - å…¼å®¹ç°æœ‰ç³»ç»Ÿ"""
    user_prompt_manager = UserPromptManager()
    
    if user_manager.is_admin(current_user["id"]):
        # ç®¡ç†å‘˜çœ‹åˆ°æ‰€æœ‰Promptæ–‡ä»¶
        prompt_files = user_prompt_manager.get_user_accessible_prompts(current_user["id"])
    else:
        # æ™®é€šç”¨æˆ·çœ‹åˆ°æ‰€æœ‰Promptæ–‡ä»¶ï¼ˆåªè¯»ï¼‰
        prompt_files = user_prompt_manager.get_user_accessible_prompts(current_user["id"])
    
    # è¿”å›æ–‡ä»¶ååˆ—è¡¨ï¼Œå…¼å®¹ç°æœ‰API
    return {"files": prompt_files}

@app.post("/api/prompt/new")
@require_auth
async def new_prompt_file(
    name: str = Body(...),
    content: str = Body(...),
    current_user: dict = Depends(get_current_user)
):
    """åˆ›å»ºæ–°Promptæ–‡ä»¶"""
    user_prompt_manager = UserPromptManager()
    
    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
    file_path = os.path.join("config_prompts", name)
    if os.path.exists(file_path):
        raise HTTPException(409, "æ–‡ä»¶å·²å­˜åœ¨")
    
    # åˆ›å»ºæ–‡ä»¶
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    # å°†æ–‡ä»¶å…³è”åˆ°ç”¨æˆ·
    user_prompt_manager.add_user_prompt(current_user["id"], name, "owned")
    
    return {"status": "created", "name": name}

@app.post("/api/prompt/file")
@require_auth
async def save_prompt_file(
    name: str = Body(...),
    content: str = Body(...),
    current_user: dict = Depends(get_current_user)
):
    """ä¿å­˜Promptæ–‡ä»¶ - åªèƒ½ç¼–è¾‘è‡ªå·±çš„æ–‡ä»¶"""
    user_prompt_manager = UserPromptManager()
    
    if not user_manager.is_admin(current_user["id"]):
        if not user_prompt_manager.can_user_edit_prompt(current_user["id"], name):
            raise HTTPException(403, "åªèƒ½ç¼–è¾‘è‡ªå·±çš„Promptæ–‡ä»¶")
    
    # ä¿å­˜æ–‡ä»¶
    file_path = os.path.join("config_prompts", name)
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    return {"status": "success", "name": name}

@app.post("/api/prompt/favorite/{prompt_filename}")
@require_auth
async def favorite_prompt(
    prompt_filename: str,
    current_user: dict = Depends(get_current_user)
):
    """æ”¶è—Promptæ–‡ä»¶"""
    user_prompt_manager = UserPromptManager()
    user_prompt_manager.add_user_prompt(current_user["id"], prompt_filename, "favorite")
    return {"message": "æ”¶è—æˆåŠŸ"}

@app.delete("/api/prompt/{prompt_filename}")
@require_auth
async def delete_prompt(
    prompt_filename: str,
    current_user: dict = Depends(get_current_user)
):
    """åˆ é™¤Promptæ–‡ä»¶ - åªèƒ½åˆ é™¤è‡ªå·±æ‹¥æœ‰çš„"""
    user_prompt_manager = UserPromptManager()
    user_prompts = user_prompt_manager.get_user_prompts(current_user["id"])
    
    if prompt_filename not in user_prompts["owned_prompts"]:
        raise HTTPException(403, "åªèƒ½åˆ é™¤è‡ªå·±çš„Promptæ–‡ä»¶")
    
    # åˆ é™¤æ–‡ä»¶
    file_path = os.path.join("config_prompts", prompt_filename)
    if os.path.exists(file_path):
        os.remove(file_path)
    
    # ç§»é™¤ç”¨æˆ·å…³è”
    user_prompt_manager.remove_user_prompt(current_user["id"], prompt_filename, "owned")
    
    return {"message": "åˆ é™¤æˆåŠŸ"}
```

## ğŸ“± å‰ç«¯ç•Œé¢é€‚é…

### ç”¨æˆ·è§’è‰²æ˜¾ç¤º

```vue
<template>
  <div class="user-info">
    <span>{{ userStore.username }}</span>
    <el-tag :type="userStore.role === 'admin' ? 'danger' : 'primary'">
      {{ userStore.role === 'admin' ? 'ç®¡ç†å‘˜' : 'ç”¨æˆ·' }}
    </el-tag>
  </div>
</template>
```

### æƒé™æ§åˆ¶ç»„ä»¶

```vue
<template>
  <div>
    <!-- åªæœ‰ç®¡ç†å‘˜å¯è§ -->
    <div v-if="hasPermission('user_manage')">
      <el-button @click="manageUsers">ç”¨æˆ·ç®¡ç†</el-button>
    </div>
    
    <!-- æ‰€æœ‰ç”¨æˆ·å¯è§ -->
    <div v-if="hasPermission('prompt_manage')">
      <el-button @click="createPrompt">åˆ›å»ºPrompt</el-button>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useUserStore } from '@/stores/user'

const userStore = useUserStore()

const hasPermission = (permission) => {
  return userStore.hasPermission(permission)
}
</script>
```

## ğŸš€ éƒ¨ç½²å’Œé…ç½®

### åˆå§‹åŒ–è„šæœ¬

```python
# init_users.py
from user_manager import UserManager

def init_default_users():
    user_manager = UserManager()
    
    # åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜
    user_manager.create_user(
        user_id="admin",
        username="ç³»ç»Ÿç®¡ç†å‘˜",
        role="admin"
    )
    
    # åˆ›å»ºé»˜è®¤ç”¨æˆ·
    user_manager.create_user(
        user_id="user1",
        username="æµ‹è¯•ç”¨æˆ·",
        role="user"
    )
    
    print("é»˜è®¤ç”¨æˆ·åˆ›å»ºå®Œæˆ")

if __name__ == "__main__":
    init_default_users()
```

### é…ç½®æ–‡ä»¶

```python
# config.py
class Config:
    # æ•°æ®å­˜å‚¨è·¯å¾„
    DATA_DIR = "data"
    
    # é»˜è®¤ç”¨æˆ·è§’è‰²
    DEFAULT_USER_ROLE = "user"
    
    # æƒé™é…ç½®
    PERMISSIONS = {
        "admin": ["*"],
        "user": ["history", "prompt_manage", "service_call", "cost_view"]
    }
```

## ğŸ“ˆ å‡çº§è·¯å¾„

### å½“å‰æ–¹æ¡ˆä¼˜åŠ¿
- **ç®€å•æ˜“ç”¨**ï¼šä¸¤çº§æƒé™ï¼Œé€»è¾‘æ¸…æ™°
- **å¿«é€Ÿéƒ¨ç½²**ï¼šJSONæ–‡ä»¶å­˜å‚¨ï¼Œé›¶ä¾èµ–
- **æˆæœ¬ä½å»‰**ï¼šæ— éœ€æ•°æ®åº“ï¼Œç»´æŠ¤ç®€å•
- **æ˜“äºæ‰©å±•**ï¼šä¸ºåç»­å‡çº§é¢„ç•™ç©ºé—´
- **å®Œå…¨å…¼å®¹**ï¼šä¿æŒç°æœ‰Promptå­˜å‚¨æ–¹å¼ä¸å˜

### æœªæ¥å‡çº§æ–¹å‘
```
å½“å‰ï¼šJSONæ–‡ä»¶ + ä¸¤çº§æƒé™ + ç°æœ‰Promptå­˜å‚¨
  â†“
ä¸­æœŸï¼šSQLite + ä¸‰çº§æƒé™ï¼ˆå¢åŠ å¼€å‘è€…è§’è‰²ï¼‰
  â†“
é•¿æœŸï¼šMySQL + å››çº§æƒé™ï¼ˆå®Œæ•´ä¼ä¸šçº§æƒé™ä½“ç³»ï¼‰
```

### å…¼å®¹æ€§è¯´æ˜
- **ç°æœ‰Promptç³»ç»Ÿ**ï¼šå®Œå…¨ä¿æŒä¸å˜ï¼Œç»§ç»­ä½¿ç”¨ `config_prompts/` ç›®å½•
- **ç”¨æˆ·æƒé™ç®¡ç†**ï¼šé€šè¿‡ `user_prompts.json` ç®¡ç†ç”¨æˆ·ä¸Promptçš„å…³è”å…³ç³»
- **APIæ¥å£**ï¼šå…¼å®¹ç°æœ‰çš„Prompt APIï¼ŒåŒæ—¶å¢åŠ æƒé™æ§åˆ¶
- **ä¸šåŠ¡é€»è¾‘**ï¼šç°æœ‰ä¸šåŠ¡ä»£ç æ— éœ€ä¿®æ”¹ï¼Œæƒé™æ§åˆ¶åœ¨APIå±‚å®ç°

## âœ… å®æ–½æ£€æŸ¥æ¸…å•

### åç«¯å¼€å‘
- [ ] å®ç°FileStorageç±»
- [ ] å®ç°UserManagerç±»
- [ ] å®ç°UserPromptManagerç±»ï¼ˆæ–°å¢ï¼‰
- [ ] ä¿æŒç°æœ‰PromptManagerç±»ä¸å˜
- [ ] æ·»åŠ æƒé™è£…é¥°å™¨
- [ ] ä¿®æ”¹APIæ¥å£æ”¯æŒæƒé™æ§åˆ¶
- [ ] å®ç°è®¤è¯æœºåˆ¶
- [ ] ç¡®ä¿ä¸ç°æœ‰Prompt APIå…¼å®¹

### å‰ç«¯å¼€å‘
- [ ] å®ç°ç”¨æˆ·çŠ¶æ€ç®¡ç†
- [ ] æ·»åŠ æƒé™æ£€æŸ¥å‡½æ•°
- [ ] ä¿®æ”¹èœå•æ˜¾ç¤ºé€»è¾‘
- [ ] é€‚é…Promptç®¡ç†ç•Œé¢
- [ ] æ·»åŠ ç”¨æˆ·è§’è‰²æ˜¾ç¤º

### æµ‹è¯•éªŒè¯
- [ ] ç®¡ç†å‘˜æƒé™æµ‹è¯•
- [ ] æ™®é€šç”¨æˆ·æƒé™æµ‹è¯•
- [ ] Promptç®¡ç†åŠŸèƒ½æµ‹è¯•
- [ ] æ•°æ®éš”ç¦»æµ‹è¯•
- [ ] æƒé™å‡çº§æµ‹è¯•
- [ ] ç°æœ‰Promptç³»ç»Ÿå…¼å®¹æ€§æµ‹è¯•
- [ ] ç”¨æˆ·Promptå…³è”å…³ç³»æµ‹è¯•

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**åˆ›å»ºæ—¶é—´**ï¼š2025å¹´7æœˆ  
**é€‚ç”¨åœºæ™¯**ï¼šå°å‹ä¼ä¸šï¼ˆ< 50äººï¼‰  
**æŠ€æœ¯æ ˆ**ï¼šFastAPI + Vue.js + JSONæ–‡ä»¶å­˜å‚¨ 