[{"content":"AICoreHub 两级用户体系设计 📋 概述 基于AICoreHub作为\u0026quot;企业AI能力的总线与中枢\u0026quot;的定位，采用两级用户体系，既满足小型企业的管理需求，又保持系统的简洁性和易用性。\n🎯 用户分级 1. 管理员 (Admin) 权限范围：系统级完全管理 典型用户：IT负责人、系统管理员、技术主管 主要职责： 用户账户管理 LLM模型配置管理 系统监控和维护 全局数据查看 2. 普通用户 (User) 权限范围：个人使用权限 典型用户：开发工程师、业务人员、客服、市场人员 主要职责： 个人Prompt模板管理 服务调用和测试 个人数据查看 📊 权限矩阵 功能模块 Admin User 说明 用户管理 ✅ 增删改查 ❌ 管理员可创建、删除、修改用户账户 LLM配置 ✅ 增删改查 ✅ 查看 管理员可配置、管理所有LLM模型 服务发现 ✅ 全部 ✅ 查看 所有用户可查看服务列表 调用历史 ✅ 全部 ✅ 个人 管理员看全部，用户只看自己的 成本监控 ✅ 全部 ✅ 个人 管理员看全局成本，用户看个人成本 Prompt管理 ✅ 增删改查所有 ✅ 增删改自己的，查看所有 用户可创建个人模板，查看所有模板 系统监控 ✅ 全部 ❌ 管理员可查看系统健康状态、QPS等 🏗️ 技术实现 后端权限控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 from enum import Enum from functools import wraps from fastapi import HTTPException, Depends from fastapi.security import HTTPBearer class UserRole(Enum): ADMIN = \u0026#34;admin\u0026#34; USER = \u0026#34;user\u0026#34; class UserManager: def __init__(self): self.storage = FileStorage() def get_user(self, user_id: str) -\u0026gt; Optional[dict]: data = self.storage.read_json(\u0026#34;users.json\u0026#34;) return data.get(\u0026#34;users\u0026#34;, {}).get(user_id) def is_admin(self, user_id: str) -\u0026gt; bool: user = self.get_user(user_id) return user and user.get(\u0026#34;role\u0026#34;) == \u0026#34;admin\u0026#34; # 权限装饰器 def require_admin(func): @wraps(func) async def wrapper(request: Request, *args, **kwargs): user_id = get_current_user_id(request) if not user_manager.is_admin(user_id): raise HTTPException(403, \u0026#34;需要管理员权限\u0026#34;) return await func(request, *args, **kwargs) return wrapper def require_auth(func): @wraps(func) async def wrapper(request: Request, *args, **kwargs): user_id = get_current_user_id(request) if not user_id: raise HTTPException(401, \u0026#34;需要登录\u0026#34;) return await func(request, *args, **kwargs) return wrapper # API接口权限控制 @app.post(\u0026#34;/api/llm/add\u0026#34;) @require_admin async def add_llm(model: dict = Body(...)): \u0026#34;\u0026#34;\u0026#34;添加LLM模型 - 仅管理员\u0026#34;\u0026#34;\u0026#34; pass @app.post(\u0026#34;/api/llm/delete\u0026#34;) @require_admin async def delete_llm(model: dict = Body(...)): \u0026#34;\u0026#34;\u0026#34;删除LLM模型 - 仅管理员\u0026#34;\u0026#34;\u0026#34; pass @app.get(\u0026#34;/api/prompt/list\u0026#34;) @require_auth async def list_prompts(current_user: dict = Depends(get_current_user)): \u0026#34;\u0026#34;\u0026#34;获取Prompt列表 - 管理员看全部，用户看全部（只读）\u0026#34;\u0026#34;\u0026#34; if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): prompts = prompt_manager.get_all_prompts() else: prompts = prompt_manager.get_all_prompts_readonly() return {\u0026#34;prompts\u0026#34;: prompts} @app.post(\u0026#34;/api/prompt/add\u0026#34;) @require_auth async def add_prompt( name: str, content: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;添加Prompt - 管理员可添加任何，用户只能添加自己的\u0026#34;\u0026#34;\u0026#34; if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): prompt_id = prompt_manager.create_prompt(name, content, None) # 管理员可创建公共模板 else: prompt_id = prompt_manager.create_prompt(name, content, current_user[\u0026#34;id\u0026#34;]) return {\u0026#34;id\u0026#34;: prompt_id, \u0026#34;message\u0026#34;: \u0026#34;创建成功\u0026#34;} @app.delete(\u0026#34;/api/prompt/{prompt_id}\u0026#34;) @require_auth async def delete_prompt( prompt_id: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;删除Prompt - 管理员可删除任何，用户只能删除自己的\u0026#34;\u0026#34;\u0026#34; prompt = prompt_manager.get_prompt(prompt_id) if not prompt: raise HTTPException(404, \u0026#34;Prompt不存在\u0026#34;) if not user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]) and prompt[\u0026#34;user_id\u0026#34;] != current_user[\u0026#34;id\u0026#34;]: raise HTTPException(403, \u0026#34;只能删除自己的Prompt\u0026#34;) prompt_manager.delete_prompt(prompt_id) return {\u0026#34;message\u0026#34;: \u0026#34;删除成功\u0026#34;} 前端权限控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // 权限配置 const PERMISSIONS = { ADMIN: [\u0026#39;*\u0026#39;], // 管理员拥有所有权限 USER: [\u0026#39;history\u0026#39;, \u0026#39;prompt_manage\u0026#39;, \u0026#39;service_call\u0026#39;, \u0026#39;cost_view\u0026#39;] } // 权限检查函数 function hasPermission(permission) { const userRole = userStore.role return PERMISSIONS[userRole].includes(\u0026#39;*\u0026#39;) || PERMISSIONS[userRole].includes(permission) } // 用户状态管理 const userStore = reactive({ id: null, username: \u0026#39;\u0026#39;, role: \u0026#39;user\u0026#39;, isAuthenticated: false }) // 菜单权限控制 const menuItems = computed(() =\u0026gt; { const items = [ { name: \u0026#39;LLM监控\u0026#39;, key: \u0026#39;dashboard\u0026#39;, permission: \u0026#39;cost_view\u0026#39; }, { name: \u0026#39;服务发现\u0026#39;, key: \u0026#39;discovery\u0026#39;, permission: \u0026#39;service_discovery\u0026#39; }, { name: \u0026#39;调用历史\u0026#39;, key: \u0026#39;history\u0026#39;, permission: \u0026#39;history\u0026#39; }, { name: \u0026#39;LLM配置\u0026#39;, key: \u0026#39;llmconfig\u0026#39;, permission: \u0026#39;llm_config\u0026#39; }, { name: \u0026#39;Prompt管理\u0026#39;, key: \u0026#39;prompt\u0026#39;, permission: \u0026#39;prompt_manage\u0026#39; }, { name: \u0026#39;帮助\u0026#39;, key: \u0026#39;help\u0026#39;, permission: \u0026#39;*\u0026#39; } ] return items.filter(item =\u0026gt; hasPermission(item.permission)) }) // Prompt管理组件权限控制 const PromptManager = { setup() { const userRole = userStore.role const isAdmin = userRole === \u0026#39;ADMIN\u0026#39; // 检查是否可以编辑Prompt const canEdit = (prompt) =\u0026gt; { return isAdmin || prompt.user_id === userStore.id } // 检查是否可以删除Prompt const canDelete = (prompt) =\u0026gt; { return isAdmin || prompt.user_id === userStore.id } // 检查是否可以创建Prompt const canCreate = () =\u0026gt; { return true // 所有用户都可以创建 } return { canEdit, canDelete, canCreate } } } 💾 数据存储方案 轻量级JSON文件存储 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 import json import os from typing import Dict, List, Optional from datetime import datetime import threading class FileStorage: def __init__(self, data_dir: str = \u0026#34;data\u0026#34;): self.data_dir = data_dir self.lock = threading.Lock() os.makedirs(data_dir, exist_ok=True) def _get_file_path(self, filename: str) -\u0026gt; str: return os.path.join(self.data_dir, filename) def read_json(self, filename: str) -\u0026gt; dict: file_path = self._get_file_path(filename) if not os.path.exists(file_path): return {} with self.lock: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: return json.load(f) def write_json(self, filename: str, data: dict): file_path = self._get_file_path(filename) with self.lock: with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: json.dump(data, f, ensure_ascii=False, indent=2) class UserManager: def __init__(self): self.storage = FileStorage() def get_user(self, user_id: str) -\u0026gt; Optional[dict]: data = self.storage.read_json(\u0026#34;users.json\u0026#34;) return data.get(\u0026#34;users\u0026#34;, {}).get(user_id) def create_user(self, user_id: str, username: str, role: str = \u0026#34;user\u0026#34;): data = self.storage.read_json(\u0026#34;users.json\u0026#34;) if \u0026#34;users\u0026#34; not in data: data[\u0026#34;users\u0026#34;] = {} data[\u0026#34;users\u0026#34;][user_id] = { \u0026#34;id\u0026#34;: user_id, \u0026#34;username\u0026#34;: username, \u0026#34;role\u0026#34;: role, \u0026#34;created_at\u0026#34;: datetime.now().isoformat() } self.storage.write_json(\u0026#34;users.json\u0026#34;, data) def is_admin(self, user_id: str) -\u0026gt; bool: user = self.get_user(user_id) return user and user.get(\u0026#34;role\u0026#34;) == \u0026#34;admin\u0026#34; class UserPromptManager: def __init__(self): self.storage = FileStorage() self.prompt_dir = \u0026#34;config_prompts\u0026#34; # 使用现有Prompt目录 def get_user_prompts(self, user_id: str) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;获取用户的Prompt关联信息\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) return data.get(\u0026#34;user_prompts\u0026#34;, {}).get(user_id, { \u0026#34;owned_prompts\u0026#34;: [], \u0026#34;favorite_prompts\u0026#34;: [], \u0026#34;created_at\u0026#34;: datetime.now().isoformat() }) def get_user_accessible_prompts(self, user_id: str) -\u0026gt; List[str]: \u0026#34;\u0026#34;\u0026#34;获取用户可访问的Prompt文件名列表\u0026#34;\u0026#34;\u0026#34; user_prompts = self.get_user_prompts(user_id) # 获取所有Prompt文件 all_prompts = [] for fname in os.listdir(self.prompt_dir): if os.path.isfile(os.path.join(self.prompt_dir, fname)): all_prompts.append(fname) # 用户可以看到所有Prompt文件（只读） return all_prompts def can_user_edit_prompt(self, user_id: str, prompt_filename: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;检查用户是否可以编辑指定Prompt文件\u0026#34;\u0026#34;\u0026#34; user_prompts = self.get_user_prompts(user_id) return prompt_filename in user_prompts[\u0026#34;owned_prompts\u0026#34;] def add_user_prompt(self, user_id: str, prompt_filename: str, prompt_type: str = \u0026#34;owned\u0026#34;): \u0026#34;\u0026#34;\u0026#34;为用户添加Prompt关联\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) if \u0026#34;user_prompts\u0026#34; not in data: data[\u0026#34;user_prompts\u0026#34;] = {} if user_id not in data[\u0026#34;user_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id] = { \u0026#34;owned_prompts\u0026#34;: [], \u0026#34;favorite_prompts\u0026#34;: [], \u0026#34;created_at\u0026#34;: datetime.now().isoformat() } if prompt_type == \u0026#34;owned\u0026#34;: if prompt_filename not in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;].append(prompt_filename) elif prompt_type == \u0026#34;favorite\u0026#34;: if prompt_filename not in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;]: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;].append(prompt_filename) self.storage.write_json(\u0026#34;user_prompts.json\u0026#34;, data) def remove_user_prompt(self, user_id: str, prompt_filename: str, prompt_type: str = \u0026#34;owned\u0026#34;): \u0026#34;\u0026#34;\u0026#34;移除用户的Prompt关联\u0026#34;\u0026#34;\u0026#34; data = self.storage.read_json(\u0026#34;user_prompts.json\u0026#34;) if user_id in data.get(\u0026#34;user_prompts\u0026#34;, {}): if prompt_type == \u0026#34;owned\u0026#34;: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;] = [ p for p in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;owned_prompts\u0026#34;] if p != prompt_filename ] elif prompt_type == \u0026#34;favorite\u0026#34;: data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;] = [ p for p in data[\u0026#34;user_prompts\u0026#34;][user_id][\u0026#34;favorite_prompts\u0026#34;] if p != prompt_filename ] self.storage.write_json(\u0026#34;user_prompts.json\u0026#34;, data) # 保持现有PromptManager不变，用于兼容现有系统 class PromptManager: def __init__(self, prompt_dir=\u0026#34;config_prompts\u0026#34;): self.prompts = {} if not os.path.exists(prompt_dir): return for fname in os.listdir(prompt_dir): fpath = os.path.join(prompt_dir, fname) if fname.endswith(\u0026#34;.yaml\u0026#34;) or fname.endswith(\u0026#34;.yml\u0026#34;): with open(fpath, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: self.prompts[fname[:-5]] = yaml.safe_load(f) elif fname.endswith(\u0026#34;.json\u0026#34;): with open(fpath, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: self.prompts[fname[:-5]] = json.load(f) elif fname.endswith(\u0026#34;.ini\u0026#34;): cp = configparser.ConfigParser() cp.read(fpath, encoding=\u0026#34;utf-8\u0026#34;) self.prompts[fname[:-4]] = {s: dict(cp.items(s)) for s in cp.sections()} def get_prompt(self, plugin, template=\u0026#34;default\u0026#34;): # plugin: 文件名（不含扩展名），template: section/key p = self.prompts.get(plugin, {}) if isinstance(p, dict): return p.get(template, \u0026#34;\u0026#34;) return p 数据文件结构 1 2 3 4 5 6 7 8 9 10 11 data/ ├── users.json # 用户数据 ├── user_prompts.json # 用户与Prompt的关联关系 ├── history.json # 调用历史 └── llm_config.json # LLM配置 config_prompts/ # 现有Prompt模板存储目录（保持不变） ├── prompt.ini # 现有Prompt文件 ├── prom # 现有Prompt文件 ├── prompt_x.ini # 现有Prompt文件 └── ... # 其他现有Prompt文件 users.json 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;users\u0026#34;: { \u0026#34;admin1\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;admin1\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;系统管理员\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T10:00:00Z\u0026#34; }, \u0026#34;user1\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;user1\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T11:00:00Z\u0026#34; } } } user_prompts.json 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;user_prompts\u0026#34;: { \u0026#34;user1\u0026#34;: { \u0026#34;owned_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;, \u0026#34;custom_prompt.yaml\u0026#34;], \u0026#34;favorite_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;], \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T10:00:00Z\u0026#34; }, \u0026#34;user2\u0026#34;: { \u0026#34;owned_prompts\u0026#34;: [\u0026#34;my_prompt.json\u0026#34;], \u0026#34;favorite_prompts\u0026#34;: [\u0026#34;prompt.ini\u0026#34;, \u0026#34;prompt_x.ini\u0026#34;], \u0026#34;created_at\u0026#34;: \u0026#34;2025-07-01T11:00:00Z\u0026#34; } } } 🔐 认证机制 简化认证方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 from fastapi import HTTPException, Depends from fastapi.security import HTTPBearer security = HTTPBearer() def get_current_user(token: str = Depends(security)): # 简化处理：token直接作为user_id # 实际项目中应使用JWT或其他认证方式 user_id = token.credentials user = user_manager.get_user(user_id) if not user: raise HTTPException(401, \u0026#34;用户不存在\u0026#34;) return user # 登录接口 @app.post(\u0026#34;/api/login\u0026#34;) async def login(username: str, password: str): # 简化处理：直接返回用户信息 # 实际项目中需要验证密码 user = user_manager.get_user_by_username(username) if not user: raise HTTPException(401, \u0026#34;用户名或密码错误\u0026#34;) return { \u0026#34;user_id\u0026#34;: user[\u0026#34;id\u0026#34;], \u0026#34;username\u0026#34;: user[\u0026#34;username\u0026#34;], \u0026#34;role\u0026#34;: user[\u0026#34;role\u0026#34;], \u0026#34;token\u0026#34;: user[\u0026#34;id\u0026#34;] # 简化处理 } # Prompt管理API接口 @app.get(\u0026#34;/api/prompt/list\u0026#34;) @require_auth async def list_prompts(current_user: dict = Depends(get_current_user)): \u0026#34;\u0026#34;\u0026#34;获取Prompt列表 - 兼容现有系统\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() if user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): # 管理员看到所有Prompt文件 prompt_files = user_prompt_manager.get_user_accessible_prompts(current_user[\u0026#34;id\u0026#34;]) else: # 普通用户看到所有Prompt文件（只读） prompt_files = user_prompt_manager.get_user_accessible_prompts(current_user[\u0026#34;id\u0026#34;]) # 返回文件名列表，兼容现有API return {\u0026#34;files\u0026#34;: prompt_files} @app.post(\u0026#34;/api/prompt/new\u0026#34;) @require_auth async def new_prompt_file( name: str = Body(...), content: str = Body(...), current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;创建新Prompt文件\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() # 检查文件是否已存在 file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, name) if os.path.exists(file_path): raise HTTPException(409, \u0026#34;文件已存在\u0026#34;) # 创建文件 with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(content) # 将文件关联到用户 user_prompt_manager.add_user_prompt(current_user[\u0026#34;id\u0026#34;], name, \u0026#34;owned\u0026#34;) return {\u0026#34;status\u0026#34;: \u0026#34;created\u0026#34;, \u0026#34;name\u0026#34;: name} @app.post(\u0026#34;/api/prompt/file\u0026#34;) @require_auth async def save_prompt_file( name: str = Body(...), content: str = Body(...), current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;保存Prompt文件 - 只能编辑自己的文件\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() if not user_manager.is_admin(current_user[\u0026#34;id\u0026#34;]): if not user_prompt_manager.can_user_edit_prompt(current_user[\u0026#34;id\u0026#34;], name): raise HTTPException(403, \u0026#34;只能编辑自己的Prompt文件\u0026#34;) # 保存文件 file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, name) with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(content) return {\u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;name\u0026#34;: name} @app.post(\u0026#34;/api/prompt/favorite/{prompt_filename}\u0026#34;) @require_auth async def favorite_prompt( prompt_filename: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;收藏Prompt文件\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() user_prompt_manager.add_user_prompt(current_user[\u0026#34;id\u0026#34;], prompt_filename, \u0026#34;favorite\u0026#34;) return {\u0026#34;message\u0026#34;: \u0026#34;收藏成功\u0026#34;} @app.delete(\u0026#34;/api/prompt/{prompt_filename}\u0026#34;) @require_auth async def delete_prompt( prompt_filename: str, current_user: dict = Depends(get_current_user) ): \u0026#34;\u0026#34;\u0026#34;删除Prompt文件 - 只能删除自己拥有的\u0026#34;\u0026#34;\u0026#34; user_prompt_manager = UserPromptManager() user_prompts = user_prompt_manager.get_user_prompts(current_user[\u0026#34;id\u0026#34;]) if prompt_filename not in user_prompts[\u0026#34;owned_prompts\u0026#34;]: raise HTTPException(403, \u0026#34;只能删除自己的Prompt文件\u0026#34;) # 删除文件 file_path = os.path.join(\u0026#34;config_prompts\u0026#34;, prompt_filename) if os.path.exists(file_path): os.remove(file_path) # 移除用户关联 user_prompt_manager.remove_user_prompt(current_user[\u0026#34;id\u0026#34;], prompt_filename, \u0026#34;owned\u0026#34;) return {\u0026#34;message\u0026#34;: \u0026#34;删除成功\u0026#34;} 📱 前端界面适配 用户角色显示 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;user-info\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ userStore.username }}\u0026lt;/span\u0026gt; \u0026lt;el-tag :type=\u0026#34;userStore.role === \u0026#39;admin\u0026#39; ? \u0026#39;danger\u0026#39; : \u0026#39;primary\u0026#39;\u0026#34;\u0026gt; {{ userStore.role === \u0026#39;admin\u0026#39; ? \u0026#39;管理员\u0026#39; : \u0026#39;用户\u0026#39; }} \u0026lt;/el-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 权限控制组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 只有管理员可见 --\u0026gt; \u0026lt;div v-if=\u0026#34;hasPermission(\u0026#39;user_manage\u0026#39;)\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;manageUsers\u0026#34;\u0026gt;用户管理\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 所有用户可见 --\u0026gt; \u0026lt;div v-if=\u0026#34;hasPermission(\u0026#39;prompt_manage\u0026#39;)\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;createPrompt\u0026#34;\u0026gt;创建Prompt\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { computed } from \u0026#39;vue\u0026#39; import { useUserStore } from \u0026#39;@/stores/user\u0026#39; const userStore = useUserStore() const hasPermission = (permission) =\u0026gt; { return userStore.hasPermission(permission) } \u0026lt;/script\u0026gt; 🚀 部署和配置 初始化脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # init_users.py from user_manager import UserManager def init_default_users(): user_manager = UserManager() # 创建默认管理员 user_manager.create_user( user_id=\u0026#34;admin\u0026#34;, username=\u0026#34;系统管理员\u0026#34;, role=\u0026#34;admin\u0026#34; ) # 创建默认用户 user_manager.create_user( user_id=\u0026#34;user1\u0026#34;, username=\u0026#34;测试用户\u0026#34;, role=\u0026#34;user\u0026#34; ) print(\u0026#34;默认用户创建完成\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: init_default_users() 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 # config.py class Config: # 数据存储路径 DATA_DIR = \u0026#34;data\u0026#34; # 默认用户角色 DEFAULT_USER_ROLE = \u0026#34;user\u0026#34; # 权限配置 PERMISSIONS = { \u0026#34;admin\u0026#34;: [\u0026#34;*\u0026#34;], \u0026#34;user\u0026#34;: [\u0026#34;history\u0026#34;, \u0026#34;prompt_manage\u0026#34;, \u0026#34;service_call\u0026#34;, \u0026#34;cost_view\u0026#34;] } 📈 升级路径 当前方案优势 简单易用：两级权限，逻辑清晰 快速部署：JSON文件存储，零依赖 成本低廉：无需数据库，维护简单 易于扩展：为后续升级预留空间 完全兼容：保持现有Prompt存储方式不变 未来升级方向 1 2 3 4 5 当前：JSON文件 + 两级权限 + 现有Prompt存储 ↓ 中期：SQLite + 三级权限（增加开发者角色） ↓ 长期：MySQL + 四级权限（完整企业级权限体系） 兼容性说明 现有Prompt系统：完全保持不变，继续使用 config_prompts/ 目录 用户权限管理：通过 user_prompts.json 管理用户与Prompt的关联关系 API接口：兼容现有的Prompt API，同时增加权限控制 业务逻辑：现有业务代码无需修改，权限控制在API层实现 ✅ 实施检查清单 后端开发 实现FileStorage类 实现UserManager类 实现UserPromptManager类（新增） 保持现有PromptManager类不变 添加权限装饰器 修改API接口支持权限控制 实现认证机制 确保与现有Prompt API兼容 前端开发 实现用户状态管理 添加权限检查函数 修改菜单显示逻辑 适配Prompt管理界面 添加用户角色显示 测试验证 管理员权限测试 普通用户权限测试 Prompt管理功能测试 数据隔离测试 权限升级测试 现有Prompt系统兼容性测试 用户Prompt关联关系测试 文档版本：v1.0\n创建时间：2025年7月\n适用场景：小型企业（\u0026lt; 50人）\n技术栈：FastAPI + Vue.js + JSON文件存储\n","date":"2025-07-31T18:22:48+08:00","permalink":"https://zhangzib123.github.io/p/aicorehub-%E4%B8%A4%E7%BA%A7%E7%94%A8%E6%88%B7%E4%BD%93%E7%B3%BB%E8%AE%BE%E8%AE%A1/","title":"AICoreHub 两级用户体系设计"},{"content":"文章标题 文章内容111\n","date":"2025-07-31T15:22:48+08:00","permalink":"https://zhangzib123.github.io/p/abc/","title":"Abc"}]